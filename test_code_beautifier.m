classdef test_code_beautifier < matlab.unittest.TestCase
    % Test suite for the code_beautifier function.

    methods (Test)

        % --- Test Default Options ---
        function testDefaultFormatting(testCase)
            rawCode = { ...
                'function y=myfunc(x);if x > 0;;y=x*2+1;else;y=0;end;disp(y);end;' ...
            };
            expectedCode = { ...
                'function y = myfunc(x)', ...
                '    if x > 0;', ...
                '        y = x * 2 + 1;', ...
                '    else', ...
                '        y = 0;', ...
                '    end', ...
                '    disp(y);', ...
                'end' ...
            };
            % Default options: IndentSize=4, UseTabs=false, SpaceAroundOperators=true,
            % SpaceAfterComma=true, ContinuationIndentOffset=1, PreserveBlankLines=true,
            % MinBlankLinesBeforeBlock=0, RemoveRedundantSemicolons=true, AddSemicolonsToStatements=false
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Default formatting failed.');
        end

        % --- Test Individual Options ---

        % IndentSize
        function testIndentSizeTwo(testCase)
            rawCode = {'if true;disp(1);end'};
            expectedCode = { ...
                'if true', ...
                '  disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 2, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'IndentSize=2 failed.');
        end

        function testIndentSizeZero(testCase) % No indentation, only structure
            rawCode = {'if true;disp(1);end'};
            expectedCode = { ...
                'if true', ...
                'disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 0, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'IndentSize=0 failed.');
        end

        % UseTabs
        function testUseTabsTrue(testCase)
            rawCode = {'if true;disp(1);end'};
            expectedCode = { ...
                'if true', ...
                [sprintf('\t') 'disp(1);'], ... % Tab character
                'end' ...
            };
            % Note: SpaceAroundOperators etc. are kept false to isolate UseTabs effect primarily on indent leading chars
            actualCode = code_beautifier(rawCode, 'UseTabs', true, 'IndentSize', 1, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'UseTabs=true failed.');
        end

        % SpaceAroundOperators (selected cases)
        function testSpaceAroundOperatorsBasic(testCase)
            rawCode = {'a=b+c; x=y*z; r=s/t; p=q^r;'};
            expectedCode = {'a = b + c; x = y * z; r = s / t; p = q ^ r;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators basic arithmetic failed.');
        end

        function testSpaceAroundOperatorsComparisonLogical(testCase)
            rawCode = {'if a==b&&c~=d; x=1; elseif e<=f||g>h; y=2; end'};
            expectedCode = {'if a == b && c ~= d; x = 1; elseif e <= f || g > h; y = 2; end'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators comparison/logical failed.');
        end
        
        function testSpaceAroundOperatorsElementWise(testCase)
            rawCode = {'M = A.*B - C./D + E.^F;'};
            expectedCode = {'M = A .* B - C ./ D + E .^ F;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators element-wise failed.');
        end

        function testNoSpaceAroundOperators(testCase)
            rawCode = {'a = b + c;'};
            expectedCode = {'a=b+c;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', false, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators=false failed.');
        end
        
        function testSpaceAroundOperatorsWithUnary(testCase)
            rawCode = {'x=-5; y=x*-1; z=obj.val+-10; arr(1)=-idx;'};
            % Expected based on current logic for SpaceAroundOperators and its unary fixes
            expectedCode = {'x = -5; y = x * -1; z = obj.val + -10; arr(1) = -idx;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators with unary operators failed.');
        end

        % SpaceAfterComma
        function testSpaceAfterCommaBasic(testCase)
            rawCode = {'myFunc(a,b,c); M=[1,2;3,4];'};
            expectedCode = {'myFunc(a, b, c); M=[1, 2;3, 4];'}; % Semicolon in matrix is not affected by SpaceAfterComma
            actualCode = code_beautifier(rawCode, 'SpaceAfterComma', true, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAfterComma=true failed.');
        end

        function testNoSpaceAfterComma(testCase)
            rawCode = {'myFunc(a, b, c); M=[1, 2; 3, 4];'};
            expectedCode = {'myFunc(a,b,c); M=[1,2;3,4];'};
            actualCode = code_beautifier(rawCode, 'SpaceAfterComma', false, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAfterComma=false failed.');
        end

        % ContinuationIndentOffset
        function testContinuationIndentOffsetDefault(testCase) % Default is 1
            rawCode = { ...
                'longName = myfunction(arg1, ...', ...
                'arg2, arg3);' ...
            };
            expectedCode = { ...
                'longName = myfunction(arg1, ...', ...
                '    arg2, arg3);' ... % Default IndentSize=4, ContinuationOffset=1 -> total 4+4=8 spaces if base was 0
            };
            % Test with IndentSize 0 to isolate continuation offset effect
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'ContinuationIndentOffset default failed.');
        end

        function testContinuationIndentOffsetCustom(testCase)
            rawCode = { ...
                'if true', ...
                '  result = firstPart + ...', ...
                '  secondPart - thirdPart;', ...
                'end' ...
            };
            expectedCode = { ...
                'if true', ...
                '  result = firstPart + ...', ... % IndentSize=2
                '      secondPart - thirdPart;', ... % IndentSize=2, ContOffset=1*IndentSize=2 -> total 2+2=4
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 2, 'ContinuationIndentOffset', 1, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'ContinuationIndentOffset custom failed.');
        end
        
        function testContinuationIndentOffsetZero(testCase)
            rawCode = { ...
                'if true', ...
                '  result = firstPart + ...', ...
                '  secondPart - thirdPart;', ...
                'end' ...
            };
            expectedCode = { ...
                'if true', ...
                '  result = firstPart + ...', ... % IndentSize=2
                '  secondPart - thirdPart;', ... % IndentSize=2, ContOffset=0 -> total 2
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 2, 'ContinuationIndentOffset', 0, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'ContinuationIndentOffset zero failed.');
        end


        % PreserveBlankLines
        function testPreserveBlankLinesTrue(testCase)
            rawCode = { ...
                'line1;', ...
                '', ... % Single blank
                'line2;', ...
                '', ... % Multiple blanks
                '', ...
                '', ...
                'line3;' ...
            };
            expectedCode = { ...
                'line1;', ...
                '', ... % Preserved
                'line2;', ...
                '', ... % Collapsed to one
                'line3;' ...
            };
            actualCode = code_beautifier(rawCode, 'PreserveBlankLines', true, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'PreserveBlankLines=true failed.');
        end

        function testPreserveBlankLinesFalse(testCase)
            rawCode = { ...
                'line1;', ...
                '', ... 
                'line2;', ...
                '', ...
                '', ...
                'line3;' ...
            };
            expectedCode = { ... % Most blank lines removed
                'line1;', ...
                'line2;', ...
                'line3;' ...
            };
            actualCode = code_beautifier(rawCode, 'PreserveBlankLines', false, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'PreserveBlankLines=false failed.');
        end

        % MinBlankLinesBeforeBlock
        function testMinBlankLinesBeforeBlockOne(testCase)
            rawCode = { ...
                'line1;', ... % No blank line before 'if'
                'if true', ...
                'disp(1);', ...
                'end', ...
                'function myfunc()', % Already one blank before 'function' due to 'end' line (if preserve=true)
                'disp(2);', ...
                'end' ...
            };
            expectedCodeWithPreserve = { ...
                'line1;', ...
                '', % Added by MinBlankLinesBeforeBlock
                'if true', ...
                '    disp(1);', ...
                'end', ... % This 'end' does not start a block
                '', % Added by MinBlankLinesBeforeBlock (assuming PreserveBlankLines might not add one after 'end')
                'function myfunc()', ...
                '    disp(2);', ...
                'end' ...
            };
             % Test with PreserveBlankLines=false to isolate MinBlankLines effect
            expectedCodeNoPreserve = { ...
                'line1;', ...
                '', % Added by MinBlankLinesBeforeBlock
                'if true', ...
                '    disp(1);', ...
                'end', ...
                '', % Added by MinBlankLinesBeforeBlock
                'function myfunc()', ...
                '    disp(2);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', true, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCodeWithPreserve, 'MinBlankLinesBeforeBlock=1 with PreserveBlankLines=true failed.');
            
            actualCodeNoPreserve = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCodeNoPreserve, expectedCodeNoPreserve, 'MinBlankLinesBeforeBlock=1 with PreserveBlankLines=false failed.');
        end

        function testMinBlankLinesBeforeBlockTwoNoExisting(testCase)
            rawCode = {'if true', 'disp(1);', 'end'};
            expectedCode = { ...
                '', % Added
                '', % Added
                'if true', ...
                '    disp(1);', ...
                'end' ...
            };
            % Test with MinBlankLinesBeforeBlock=2, and block is at start of file (after potential blanks)
            % The logic should prevent adding blanks at the very start of the file (fileLinecount > 0 check)
            % So, if 'if true' is the first actual content line, it shouldn't get blanks before it.
            % Let's test with a preceding line.
            rawCodePreceded = {'firstLine;', 'if true', 'disp(1);', 'end'};
             expectedCodePreceded = { ...
                'firstLine;', ...
                '', % Added
                '', % Added
                'if true', ...
                '    disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCodePreceded, 'MinBlankLinesBeforeBlock', 2, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCodePreceded, 'MinBlankLinesBeforeBlock=2 with no existing blanks failed.');
        end
        
        function testMinBlankLinesBeforeBlockAtStartOfFile(testCase)
            rawCode = {'if true', 'disp(1);', 'end'};
            expectedCode = { ... % No blanks added at absolute start of file
                'if true', ...
                '    disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'MinBlankLinesBeforeBlock at start of file failed.');
        end


        % RemoveRedundantSemicolons
        function testRemoveRedundantSemicolonsTrue(testCase)
            rawCode = {'a=1;; b=2; c=3;;;; end;'}; % also tests end;
            expectedCode = {'a=1; b=2; c=3; end'};
            actualCode = code_beautifier(rawCode, 'RemoveRedundantSemicolons', true, 'IndentSize',0,'SpaceAroundOperators',false);
            testCase.verifyEqual(actualCode, expectedCode, 'RemoveRedundantSemicolons=true failed.');
        end

        function testRemoveRedundantSemicolonsFalse(testCase)
            rawCode = {'a=1;; b=2; c=3;;;; end;'};
            expectedCode = {'a=1;; b=2; c=3;;;; end;'};
            actualCode = code_beautifier(rawCode, 'RemoveRedundantSemicolons', false, 'IndentSize',0,'SpaceAroundOperators',false);
            testCase.verifyEqual(actualCode, expectedCode, 'RemoveRedundantSemicolons=false failed.');
        end
        
        function testRemoveRedundantSemicolonsEndFunction(testCase)
            rawCode = {'function myFunc(); disp(1);end;'};
            expectedCode = {'function myFunc(); disp(1);end'}; % end; for function should not remove semicolon from end
            actualCode = code_beautifier(rawCode, 'RemoveRedundantSemicolons', true, 'IndentSize',0,'SpaceAroundOperators',false);
            testCase.verifyEqual(actualCode, expectedCode, 'RemoveRedundantSemicolons end; for function failed.');
        end


        % AddSemicolonsToStatements
        function testAddSemicolonsToStatementsTrue(testCase)
            rawCode = { ...
                'disp("hello")', ... % Should add
                'myVar', ...         % Should NOT add
                'a = b + c', ...    % Is assignment, should NOT add (though ; is typical)
                'if x > 0', ...     % Is keyword line, should NOT add
                '  plot(x,y)', ...  % Should add
                'end', ...
                '1+2' ...           % Simple expression, should add
            };
            expectedCode = { ...
                'disp("hello");', ...
                'myVar', ...
                'a = b + c', ... % Semicolon not added by this option for assignments
                'if x > 0', ...
                '  plot(x,y);', ...
                'end', ...
                '1+2;' ...
            };
            % Note: AddSemicolonsToStatements is independent of RemoveRedundantSemicolons
            actualCode = code_beautifier(rawCode, 'AddSemicolonsToStatements', true, 'IndentSize',0,'SpaceAroundOperators',true, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'AddSemicolonsToStatements=true failed.');
        end

        function testAddSemicolonsToStatementsFalse(testCase)
            rawCode = { ...
                'disp("hello")', ...
                'myVar', ...
                'a = b + c', ...
                'plot(x,y)' ...
            };
            expectedCode = { ... % Output suppressed by default beautifier options if not an assignment
                'disp("hello")', ...
                'myVar', ...
                'a = b + c', ...
                'plot(x,y)' ...
            };
            actualCode = code_beautifier(rawCode, 'AddSemicolonsToStatements', false, 'IndentSize',0,'SpaceAroundOperators',true, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'AddSemicolonsToStatements=false failed.');
        end
        
        function testAddSemicolonsHoldOn(testCase)
            rawCode = {'hold on'};
            expectedCode = {'hold on;'};
            actualCode = code_beautifier(rawCode, 'AddSemicolonsToStatements', true, 'IndentSize',0,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode, 'AddSemicolonsToStatements for "hold on" failed.');
        end

        % OutputFormat
        function testOutputFormatChar(testCase)
            rawCode = {'a=1;','b=2;'};
            expectedCode_char = sprintf('a=1;\nb=2;');
            actualCode = code_beautifier(rawCode, 'OutputFormat', 'char', 'IndentSize',0,'SpaceAroundOperators',false,'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode_char, 'OutputFormat=char failed.');
            testCase.verifyClass(actualCode, 'char', 'OutputFormat=char did not return char.');
        end

        function testOutputFormatCell(testCase)
            rawCode = {'a=1;','b=2;'};
            expectedCode_cell = {'a=1;','b=2;'};
            actualCode = code_beautifier(rawCode, 'OutputFormat', 'cell', 'IndentSize',0,'SpaceAroundOperators',false,'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode_cell, 'OutputFormat=cell failed.');
            testCase.verifyClass(actualCode, 'cell', 'OutputFormat=cell did not return cell.');
        end
        
        % --- Test Combinations of Options ---
        function testCombinationStandardStyle(testCase)
            rawCode = { ...
                'function myFun( list, limit )', ...
                '% This is a test function', ...
                '  total=0;', ...
                'for i=1:numel(list)', ...
                '    if list(i)>limit; total = total+list(i);', ...
                '    else; total = total-list(i);end;', ...
                'end % End for loop', ...
                'disp(total);', ...
                'end %% End function myFun' ...
            };
            expectedCode = { ...
                'function myFun(list, limit)', ...
                '% This is a test function', ...
                '    total = 0;', ...
                '    for i = 1:numel(list)', ...
                '        if list(i) > limit; total = total + list(i);', ...
                '        else; total = total - list(i);', ...
                '        end; % End for loop', ... % Semicolon added to 'end' because it's not 'end;' for a block keyword
                '    end', ... % Assuming AddSemicolonsToStatements=false by default, so this 'end' line is not affected by it
                '    disp(total);', ...
                'end %% End function myFun' ...
            };
             % Default: IndentSize=4, SpaceAroundOperators=true, SpaceAfterComma=true, RemoveRedundantSemicolons=true
             % AddSemicolonsToStatements=false
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Standard style combination failed.');
        end

        function testCombinationMinimalStyle(testCase)
            rawCode = { ...
                'function myFun( list, limit )', ...
                '% This is a test function', ...
                '  total=0;', ...
                'for i=1:numel(list)', ...
                '    if list(i)>limit; total = total+list(i);', ...
                '    else; total = total-list(i);end;', ...
                'end % End for loop', ...
                'disp(total);', ...
                'end %% End function myFun' ...
            };
            expectedCode = { ...
                'function myFun(list,limit)', ...
                '% This is a test function', ...
                'total=0;', ...
                'for i=1:numel(list)', ...
                'if list(i)>limit;total=total+list(i);', ...
                'else;total=total-list(i);end;', ...
                'end % End for loop', ...
                'disp(total);', ...
                'end %% End function myFun' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 0, 'SpaceAroundOperators', false, 'SpaceAfterComma', false, 'RemoveRedundantSemicolons', true);
            testCase.verifyEqual(actualCode, expectedCode, 'Minimal style combination failed.');
        end

        % --- Edge Cases ---
        function testEmptyInputString(testCase)
            rawCode = '';
            expectedCode = {''}; % Should return a cell containing an empty string
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Empty input string failed.');
        end

        function testEmptyInputCell(testCase)
            rawCode = {''};
            expectedCode = {''};
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Empty input cell failed.');
        end
        
        function testEmptyInputStringArray(testCase)
            rawCode = string('');
            expectedCode = {''};
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Empty input string array failed.');
        end
        
        function testMultipleEmptyLines(testCase)
            rawCode = {'', '', ''};
            expectedCode = {'', ''}; % Default PreserveBlankLines=true collapses multiple to one (or two if first/last?)
                                     % Current PreserveBlankLines collapses to one.
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Multiple empty lines failed.');
        end

        function testCodeOnlyComments(testCase)
            rawCode = { ...
                '% Line comment 1', ...
                '%{', ...
                '  Block comment line 1', ...
                '  Block comment line 2', ...
                '%}', ...
                '    % Indented line comment' ...
            };
            expectedCode = { ...
                '% Line comment 1', ...
                '%{', ...
                '  Block comment line 1', ... % Block comments preserve internal spacing relative to base indent
                '  Block comment line 2', ...
                '%}', ...
                '    % Indented line comment' ... % Indented comments keep their relative indent
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 4);
            testCase.verifyEqual(actualCode, expectedCode, 'Code only comments failed.');
        end
        
        function testCodeWithMixedTabsAndSpaces(testCase)
            rawCode = {sprintf('if true\n\t  disp(1); % Mixed tab and spaces\nend')}; % Input as single string with \n
            expectedCode = { ...
                'if true', ...
                '    disp(1); % Mixed tab and spaces', ... % Default IndentSize=4 spaces
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'UseTabs', false, 'IndentSize', 4, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons',false, 'AddSemicolonsToStatements',true);
            testCase.verifyEqual(actualCode, expectedCode, 'Mixed tabs and spaces normalization failed.');
        end
        
        function testLineWithOnlyWhitespace(testCase)
            rawCode = {'   ', 'line1;', '  \t  ', 'line2;'};
            expectedCode = {'', 'line1;', '', 'line2;'}; % Whitespace lines become empty
            actualCode = code_beautifier(rawCode, 'PreserveBlankLines', true, 'IndentSize',0,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode, 'Lines with only whitespace failed.');
        end

        % --- Specific Fixes/Features Verified ---
        function testCommentExtractionWithQuotes(testCase)
            rawCode = { ...
                'disp(''string with % sign and single quotes''); % comment after single quote string', ...
                'disp("string with % sign and double quotes"); % comment after double quote string', ...
                'url = "https://example.com/%20test"; % percent in URL' ...
            };
            expectedCode = { ...
                'disp(''string with % sign and single quotes''); % comment after single quote string', ...
                'disp("string with % sign and double quotes"); % comment after double quote string', ...
                'url = "https://example.com/%20test"; % percent in URL' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 0, 'SpaceAroundOperators', true, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'Comment extraction with % in strings failed.');
        end
        
        function testCommentOnlyLineIndentation(testCase)
            rawCode = { ...
                'if true', ...
                '    % This comment is inside if', ...
                '    call_func();', ...
                'end'};
            expectedCode = { ...
                'if true', ...
                '    % This comment is inside if', ...
                '    call_func();', ...
                'end'};
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'AddSemicolonsToStatements', true, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'Comment-only line indentation failed.');
        end

        function testSwitchBlockIndentation(testCase)
            rawCode = { ...
                'switch variable_expr', ...
                'case 1 % Comment for case 1', ...
                'disp("Option 1");', ...
                '    % Indented comment', ...
                'case {2,3}', ...
                '  subroutine_call(variable_expr);', ...
                'otherwise', ...
                '  disp("Other");', ...
                'end % Switch end' ...
            };
            expectedCode = { ...
                'switch variable_expr', ...
                '    case 1 % Comment for case 1', ...
                '        disp("Option 1");', ...
                '            % Indented comment', ... % Comments maintain their relative indent from current block level + case level
                '    case {2,3}', ...
                '        subroutine_call(variable_expr);', ...
                '    otherwise', ...
                '        disp("Other");', ...
                'end % Switch end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'Switch block indentation failed.');
        end
        
        function testNestedSwitchBlockIndentation(testCase)
            rawCode = { ...
                'switch val1', ...
                'case 1', ...
                '  switch val2', ...
                '  case 10', ...
                '    disp(110);', ...
                '  otherwise', ...
                '    disp(100);', ...
                '  end', ... % Inner switch end
                'case 2', ...
                '  disp(2);', ...
                'end % Outer switch end'};
            expectedCode = { ...
                'switch val1', ...
                '    case 1', ...
                '        switch val2', ...
                '            case 10', ...
                '                disp(110);', ...
                '            otherwise', ...
                '                disp(100);', ...
                '        end', ... % Inner switch end
                '    case 2', ...
                '        disp(2);', ...
                'end % Outer switch end'};
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'Nested Switch block indentation failed.');
        end


        function testBlankLineHandlingMinAndPreserve(testCase)
            rawCode = { ...
                'line1;', ...
                '', ... % User has one blank line
                'if condition1', ... % Block 1
                '    line2;', ...
                'end', ...
                'if condition2', ... % Block 2, no user blank lines before
                '    line3;', ...
                'end', ...
                '', ... % User has three blank lines
                '', ...
                '', ...
                'if condition3', ... % Block 3
                '    line4;', ...
                'end' ...
            };
            expectedCode = { ...
                'line1;', ...
                '', % Min=1, Existing=1 (preserved) -> 1 blank
                '', % Min=1 -> 1 blank
                'if condition1', ...
                '    line2;', ...
                'end', ...
                '', % Min=1, Existing=0 -> 1 blank
                'if condition2', ...
                '    line3;', ...
                'end', ...
                '', % Min=1, Existing=1 (preserved from user's multiple) -> 1 blank
                'if condition3', ...
                '    line4;', ...
                'end' ...
            };
            % PreserveBlankLines=true (default) collapses multiple to one.
            % MinBlankLinesBeforeBlock=1 ensures at least one blank.
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', true, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'MinBlankLinesBeforeBlock=1 and PreserveBlankLines=true interaction failed.');

            expectedCodeMin2 = { ...
                'line1;', ...
                '', % Min=2, Existing=1 (preserved) -> adds 1 to make 2 blanks
                '', 
                'if condition1', ...
                '    line2;', ...
                'end', ...
                '', % Min=2, Existing=0 -> adds 2 blanks
                '',
                'if condition2', ...
                '    line3;', ...
                'end', ...
                '', % Min=2, Existing=1 (preserved) -> adds 1 to make 2 blanks
                '',
                'if condition3', ...
                '    line4;', ...
                'end' ...
            };
            actualCodeMin2 = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 2, 'PreserveBlankLines', true, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCodeMin2, expectedCodeMin2, 'MinBlankLinesBeforeBlock=2 and PreserveBlankLines=true interaction failed.');
        end
        
        function testPreserveBlankLinesFalseWithMinBlank(testCase)
             rawCode = { ...
                'line1;', ...
                '', ... 
                '', ... % User has two blank lines
                'if condition1', ... 
                '    line2;', ...
                'end'};
            expectedCode = { ...
                'line1;', ...
                '', % Min=1, Preserve=false means user blanks are ignored, MinBlank forces one.
                'if condition1', ...
                '    line2;', ...
                'end'};
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'MinBlankLinesBeforeBlock=1 and PreserveBlankLines=false interaction failed.');
        end

    end % methods (Test)
end % classdef
