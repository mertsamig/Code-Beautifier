classdef test_code_beautifier < matlab.unittest.TestCase
    % Test suite for the code_beautifier function.

    methods (Test)

        % --- Test Default Options ---
        function testDefaultFormatting(testCase)
            rawCode = { ...
                'function y=myfunc(x);if x > 0;;y=x*2+1;else;y=0;end;disp(y);end;' ...
            };
            expectedCode = { ...
                'function y = myfunc(x)', ...
                '    if x > 0;', ...
                '        y = x * 2 + 1;', ...
                '    else', ...
                '        y = 0;', ...
                '    end', ...
                '    disp(y);', ...
                'end' ...
            };
            % Default options: IndentSize=4, UseTabs=false, SpaceAroundOperators=true,
            % SpaceAfterComma=true, ContinuationIndentOffset=1, PreserveBlankLines=true,
            % MinBlankLinesBeforeBlock=0, RemoveRedundantSemicolons=true, AddSemicolonsToStatements=false
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Default formatting failed.');
        end

        % --- Test Individual Options ---

        % IndentSize
        function testIndentSizeTwo(testCase)
            rawCode = {'if true;disp(1);end'};
            expectedCode = { ...
                'if true', ...
                '  disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 2, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'IndentSize=2 failed.');
        end

        function testIndentSizeZero(testCase) % No indentation, only structure
            rawCode = {'if true;disp(1);end'};
            expectedCode = { ...
                'if true', ...
                'disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 0, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'IndentSize=0 failed.');
        end

        % UseTabs
        function testUseTabsTrue(testCase)
            rawCode = {'if true;disp(1);end'};
            expectedCode = { ...
                'if true', ...
                [sprintf('\t') 'disp(1);'], ... % Tab character
                'end' ...
            };
            % Note: SpaceAroundOperators etc. are kept false to isolate UseTabs effect primarily on indent leading chars
            actualCode = code_beautifier(rawCode, 'UseTabs', true, 'IndentSize', 1, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'UseTabs=true failed.');
        end

        % SpaceAroundOperators (selected cases)
        function testSpaceAroundOperatorsBasic(testCase)
            rawCode = {'a=b+c; x=y*z; r=s/t; p=q^r;'};
            expectedCode = {'a = b + c; x = y * z; r = s / t; p = q ^ r;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators basic arithmetic failed.');
        end

        function testSpaceAroundOperatorsComparisonLogical(testCase)
            rawCode = {'if a==b&&c~=d; x=1; elseif e<=f||g>h; y=2; end'};
            expectedCode = {'if a == b && c ~= d; x = 1; elseif e <= f || g > h; y = 2; end'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators comparison/logical failed.');
        end
        
        function testSpaceAroundOperatorsElementWise(testCase)
            rawCode = {'M = A.*B - C./D + E.^F;'};
            expectedCode = {'M = A .* B - C ./ D + E .^ F;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators element-wise failed.');
        end

        function testNoSpaceAroundOperators(testCase)
            rawCode = {'a = b + c;'};
            expectedCode = {'a=b+c;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', false, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators=false failed.');
        end
        
        function testSpaceAroundOperatorsWithUnary(testCase)
            rawCode = {'x=-5; y=x*-1; z=obj.val+-10; arr(1)=-idx;'};
            % Expected based on current logic for SpaceAroundOperators and its unary fixes
            expectedCode = {'x = -5; y = x * -1; z = obj.val + -10; arr(1) = -idx;'};
            actualCode = code_beautifier(rawCode, 'SpaceAroundOperators', true, 'IndentSize', 0, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAroundOperators with unary operators failed.');
        end

        % SpaceAfterComma
        function testSpaceAfterCommaBasic(testCase)
            rawCode = {'myFunc(a,b,c); M=[1,2;3,4];'};
            expectedCode = {'myFunc(a, b, c); M=[1, 2;3, 4];'}; % Semicolon in matrix is not affected by SpaceAfterComma
            actualCode = code_beautifier(rawCode, 'SpaceAfterComma', true, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAfterComma=true failed.');
        end

        function testNoSpaceAfterComma(testCase)
            rawCode = {'myFunc(a, b, c); M=[1, 2; 3, 4];'};
            expectedCode = {'myFunc(a,b,c); M=[1,2;3,4];'};
            actualCode = code_beautifier(rawCode, 'SpaceAfterComma', false, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'SpaceAfterComma=false failed.');
        end

        % ContinuationIndentOffset
        function testContinuationIndentOffsetDefault(testCase) % Default is 1
            rawCode = { ...
                'longName = myfunction(arg1, ...', ...
                'arg2, arg3);' ...
            };
            expectedCode = { ...
                'longName = myfunction(arg1, ...', ...
                '    arg2, arg3);' ... % Default IndentSize=4, ContinuationOffset=1 -> total 4+4=8 spaces if base was 0
            };
            % Test with IndentSize 0 to isolate continuation offset effect
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'ContinuationIndentOffset default failed.');
        end

        function testContinuationIndentOffsetCustom(testCase)
            rawCode = { ...
                'if true', ...
                '  result = firstPart + ...', ...
                '  secondPart - thirdPart;', ...
                'end' ...
            };
            expectedCode = { ...
                'if true', ...
                '  result = firstPart + ...', ... % IndentSize=2
                '      secondPart - thirdPart;', ... % IndentSize=2, ContOffset=1*IndentSize=2 -> total 2+2=4
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 2, 'ContinuationIndentOffset', 1, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'ContinuationIndentOffset custom failed.');
        end
        
        function testContinuationIndentOffsetZero(testCase)
            rawCode = { ...
                'if true', ...
                '  result = firstPart + ...', ...
                '  secondPart - thirdPart;', ...
                'end' ...
            };
            expectedCode = { ...
                'if true', ...
                '  result = firstPart + ...', ... % IndentSize=2
                '  secondPart - thirdPart;', ... % IndentSize=2, ContOffset=0 -> total 2
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 2, 'ContinuationIndentOffset', 0, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'ContinuationIndentOffset zero failed.');
        end


        % PreserveBlankLines
        function testPreserveBlankLinesTrue(testCase)
            rawCode = { ...
                'line1;', ...
                '', ... % Single blank
                'line2;', ...
                '', ... % Multiple blanks
                '', ...
                '', ...
                'line3;' ...
            };
            expectedCode = { ...
                'line1;', ...
                '', ... % Preserved
                'line2;', ...
                '', ... % Collapsed to one
                'line3;' ...
            };
            actualCode = code_beautifier(rawCode, 'PreserveBlankLines', true, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'PreserveBlankLines=true failed.');
        end

        function testPreserveBlankLinesFalse(testCase)
            rawCode = { ...
                'line1;', ...
                '', ... 
                'line2;', ...
                '', ...
                '', ...
                'line3;' ...
            };
            expectedCode = { ... % Most blank lines removed
                'line1;', ...
                'line2;', ...
                'line3;' ...
            };
            actualCode = code_beautifier(rawCode, 'PreserveBlankLines', false, 'IndentSize', 0, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'PreserveBlankLines=false failed.');
        end

        % MinBlankLinesBeforeBlock
        function testMinBlankLinesBeforeBlockOne(testCase)
            rawCode = { ...
                'line1;', ... % No blank line before 'if'
                'if true', ...
                'disp(1);', ...
                'end', ...
                'function myfunc()', % Already one blank before 'function' due to 'end' line (if preserve=true)
                'disp(2);', ...
                'end' ...
            };
            expectedCodeWithPreserve = { ...
                'line1;', ...
                '', % Added by MinBlankLinesBeforeBlock
                'if true', ...
                '    disp(1);', ...
                'end', ... % This 'end' does not start a block
                '', % Added by MinBlankLinesBeforeBlock (assuming PreserveBlankLines might not add one after 'end')
                'function myfunc()', ...
                '    disp(2);', ...
                'end' ...
            };
             % Test with PreserveBlankLines=false to isolate MinBlankLines effect
            expectedCodeNoPreserve = { ...
                'line1;', ...
                '', % Added by MinBlankLinesBeforeBlock
                'if true', ...
                '    disp(1);', ...
                'end', ...
                '', % Added by MinBlankLinesBeforeBlock
                'function myfunc()', ...
                '    disp(2);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', true, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCodeWithPreserve, 'MinBlankLinesBeforeBlock=1 with PreserveBlankLines=true failed.');
            
            actualCodeNoPreserve = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCodeNoPreserve, expectedCodeNoPreserve, 'MinBlankLinesBeforeBlock=1 with PreserveBlankLines=false failed.');
        end

        function testMinBlankLinesBeforeBlockTwoNoExisting(testCase)
            rawCode = {'if true', 'disp(1);', 'end'};
            expectedCode = { ...
                '', % Added
                '', % Added
                'if true', ...
                '    disp(1);', ...
                'end' ...
            };
            % Test with MinBlankLinesBeforeBlock=2, and block is at start of file (after potential blanks)
            % The logic should prevent adding blanks at the very start of the file (fileLinecount > 0 check)
            % So, if 'if true' is the first actual content line, it shouldn't get blanks before it.
            % Let's test with a preceding line.
            rawCodePreceded = {'firstLine;', 'if true', 'disp(1);', 'end'};
             expectedCodePreceded = { ...
                'firstLine;', ...
                '', % Added
                '', % Added
                'if true', ...
                '    disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCodePreceded, 'MinBlankLinesBeforeBlock', 2, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCodePreceded, 'MinBlankLinesBeforeBlock=2 with no existing blanks failed.');
        end
        
        function testMinBlankLinesBeforeBlockAtStartOfFile(testCase)
            rawCode = {'if true', 'disp(1);', 'end'};
            expectedCode = { ... % No blanks added at absolute start of file
                'if true', ...
                '    disp(1);', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'MinBlankLinesBeforeBlock at start of file failed.');
        end


        % RemoveRedundantSemicolons
        function testRemoveRedundantSemicolonsTrue(testCase)
            rawCode = {'a=1;; b=2; c=3;;;; end;'}; % also tests end;
            expectedCode = {'a=1; b=2; c=3; end'};
            actualCode = code_beautifier(rawCode, 'RemoveRedundantSemicolons', true, 'IndentSize',0,'SpaceAroundOperators',false);
            testCase.verifyEqual(actualCode, expectedCode, 'RemoveRedundantSemicolons=true failed.');
        end

        function testRemoveRedundantSemicolonsFalse(testCase)
            rawCode = {'a=1;; b=2; c=3;;;; end;'};
            expectedCode = {'a=1;; b=2; c=3;;;; end;'};
            actualCode = code_beautifier(rawCode, 'RemoveRedundantSemicolons', false, 'IndentSize',0,'SpaceAroundOperators',false);
            testCase.verifyEqual(actualCode, expectedCode, 'RemoveRedundantSemicolons=false failed.');
        end
        
        function testRemoveRedundantSemicolonsEndFunction(testCase)
            rawCode = {'function myFunc(); disp(1);end;'};
            expectedCode = {'function myFunc(); disp(1);end'}; % end; for function should not remove semicolon from end
            actualCode = code_beautifier(rawCode, 'RemoveRedundantSemicolons', true, 'IndentSize',0,'SpaceAroundOperators',false);
            testCase.verifyEqual(actualCode, expectedCode, 'RemoveRedundantSemicolons end; for function failed.');
        end


        % AddSemicolonsToStatements
        function testAddSemicolonsToStatementsTrue(testCase)
            rawCode = { ...
                'disp("hello")', ... % Should add
                'myVar', ...         % Should NOT add
                'a = b + c', ...    % Is assignment, should NOT add (though ; is typical)
                'if x > 0', ...     % Is keyword line, should NOT add
                '  plot(x,y)', ...  % Should add
                'end', ...
                '1+2' ...           % Simple expression, should add
            };
            expectedCode = { ...
                'disp("hello");', ...
                'myVar', ...
                'a = b + c', ... % Semicolon not added by this option for assignments
                'if x > 0', ...
                '  plot(x,y);', ...
                'end', ...
                '1+2;' ...
            };
            % Note: AddSemicolonsToStatements is independent of RemoveRedundantSemicolons
            actualCode = code_beautifier(rawCode, 'AddSemicolonsToStatements', true, 'IndentSize',0,'SpaceAroundOperators',true, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'AddSemicolonsToStatements=true failed.');
        end

        function testAddSemicolonsToStatementsFalse(testCase)
            rawCode = { ...
                'disp("hello")', ...
                'myVar', ...
                'a = b + c', ...
                'plot(x,y)' ...
            };
            expectedCode = { ... % Output suppressed by default beautifier options if not an assignment
                'disp("hello")', ...
                'myVar', ...
                'a = b + c', ...
                'plot(x,y)' ...
            };
            actualCode = code_beautifier(rawCode, 'AddSemicolonsToStatements', false, 'IndentSize',0,'SpaceAroundOperators',true, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'AddSemicolonsToStatements=false failed.');
        end
        
        function testAddSemicolonsHoldOn(testCase)
            rawCode = {'hold on'};
            expectedCode = {'hold on;'};
            actualCode = code_beautifier(rawCode, 'AddSemicolonsToStatements', true, 'IndentSize',0,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode, 'AddSemicolonsToStatements for "hold on" failed.');
        end

        % OutputFormat
        function testOutputFormatChar(testCase)
            rawCode = {'a=1;','b=2;'};
            expectedCode_char = sprintf('a=1;\nb=2;');
            actualCode = code_beautifier(rawCode, 'OutputFormat', 'char', 'IndentSize',0,'SpaceAroundOperators',false,'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode_char, 'OutputFormat=char failed.');
            testCase.verifyClass(actualCode, 'char', 'OutputFormat=char did not return char.');
        end

        function testOutputFormatCell(testCase)
            rawCode = {'a=1;','b=2;'};
            expectedCode_cell = {'a=1;','b=2;'};
            actualCode = code_beautifier(rawCode, 'OutputFormat', 'cell', 'IndentSize',0,'SpaceAroundOperators',false,'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode_cell, 'OutputFormat=cell failed.');
            testCase.verifyClass(actualCode, 'cell', 'OutputFormat=cell did not return cell.');
        end
        
        % --- Test Combinations of Options ---
        function testCombinationStandardStyle(testCase)
            rawCode = { ...
                'function myFun( list, limit )', ...
                '% This is a test function', ...
                '  total=0;', ...
                'for i=1:numel(list)', ...
                '    if list(i)>limit; total = total+list(i);', ...
                '    else; total = total-list(i);end;', ...
                'end % End for loop', ...
                'disp(total);', ...
                'end %% End function myFun' ...
            };
            expectedCode = { ...
                'function myFun(list, limit)', ...
                '% This is a test function', ...
                '    total = 0;', ...
                '    for i = 1:numel(list)', ...
                '        if list(i) > limit; total = total + list(i);', ...
                '        else; total = total - list(i);', ...
                '        end; % End for loop', ... % Semicolon added to 'end' because it's not 'end;' for a block keyword
                '    end', ... % Assuming AddSemicolonsToStatements=false by default, so this 'end' line is not affected by it
                '    disp(total);', ...
                'end %% End function myFun' ...
            };
             % Default: IndentSize=4, SpaceAroundOperators=true, SpaceAfterComma=true, RemoveRedundantSemicolons=true
             % AddSemicolonsToStatements=false
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Standard style combination failed.');
        end

        function testCombinationMinimalStyle(testCase)
            rawCode = { ...
                'function myFun( list, limit )', ...
                '% This is a test function', ...
                '  total=0;', ...
                'for i=1:numel(list)', ...
                '    if list(i)>limit; total = total+list(i);', ...
                '    else; total = total-list(i);end;', ...
                'end % End for loop', ...
                'disp(total);', ...
                'end %% End function myFun' ...
            };
            expectedCode = { ...
                'function myFun(list,limit)', ...
                '% This is a test function', ...
                'total=0;', ...
                'for i=1:numel(list)', ...
                'if list(i)>limit;total=total+list(i);', ...
                'else;total=total-list(i);end;', ...
                'end % End for loop', ...
                'disp(total);', ...
                'end %% End function myFun' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 0, 'SpaceAroundOperators', false, 'SpaceAfterComma', false, 'RemoveRedundantSemicolons', true);
            testCase.verifyEqual(actualCode, expectedCode, 'Minimal style combination failed.');
        end

        % --- Edge Cases ---
        function testEmptyInputString(testCase)
            rawCode = '';
            expectedCode = {''}; % Should return a cell containing an empty string
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Empty input string failed.');
        end

        function testEmptyInputCell(testCase)
            rawCode = {''};
            expectedCode = {''};
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Empty input cell failed.');
        end
        
        function testEmptyInputStringArray(testCase)
            rawCode = string('');
            expectedCode = {''};
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Empty input string array failed.');
        end
        
        function testMultipleEmptyLines(testCase)
            rawCode = {'', '', ''};
            expectedCode = {'', ''}; % Default PreserveBlankLines=true collapses multiple to one (or two if first/last?)
                                     % Current PreserveBlankLines collapses to one.
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Multiple empty lines failed.');
        end

        function testCodeOnlyComments(testCase)
            rawCode = { ...
                '% Line comment 1', ...
                '%{', ...
                '  Block comment line 1', ...
                '  Block comment line 2', ...
                '%}', ...
                '    % Indented line comment' ...
            };
            expectedCode = { ...
                '% Line comment 1', ...
                '%{', ...
                '  Block comment line 1', ... % Block comments preserve internal spacing relative to base indent
                '  Block comment line 2', ...
                '%}', ...
                '    % Indented line comment' ... % Indented comments keep their relative indent
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 4);
            testCase.verifyEqual(actualCode, expectedCode, 'Code only comments failed.');
        end
        
        function testCodeWithMixedTabsAndSpaces(testCase)
            rawCode = {sprintf('if true\n\t  disp(1); % Mixed tab and spaces\nend')}; % Input as single string with \n
            expectedCode = { ...
                'if true', ...
                '    disp(1); % Mixed tab and spaces', ... % Default IndentSize=4 spaces
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'UseTabs', false, 'IndentSize', 4, 'SpaceAroundOperators',false, 'RemoveRedundantSemicolons',false, 'AddSemicolonsToStatements',true);
            testCase.verifyEqual(actualCode, expectedCode, 'Mixed tabs and spaces normalization failed.');
        end
        
        function testLineWithOnlyWhitespace(testCase)
            rawCode = {'   ', 'line1;', '  \t  ', 'line2;'};
            expectedCode = {'', 'line1;', '', 'line2;'}; % Whitespace lines become empty
            actualCode = code_beautifier(rawCode, 'PreserveBlankLines', true, 'IndentSize',0,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons',false);
            testCase.verifyEqual(actualCode, expectedCode, 'Lines with only whitespace failed.');
        end

        % --- Specific Fixes/Features Verified ---
        function testCommentExtractionWithQuotes(testCase)
            rawCode = { ...
                'disp(''string with % sign and single quotes''); % comment after single quote string', ...
                'disp("string with % sign and double quotes"); % comment after double quote string', ...
                'url = "https://example.com/%20test"; % percent in URL' ...
            };
            expectedCode = { ...
                'disp(''string with % sign and single quotes''); % comment after single quote string', ...
                'disp("string with % sign and double quotes"); % comment after double quote string', ...
                'url = "https://example.com/%20test"; % percent in URL' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 0, 'SpaceAroundOperators', true, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'Comment extraction with % in strings failed.');
        end
        
        function testCommentOnlyLineIndentation(testCase)
            rawCode = { ...
                'if true', ...
                '    % This comment is inside if', ...
                '    call_func();', ...
                'end'};
            expectedCode = { ...
                'if true', ...
                '    % This comment is inside if', ...
                '    call_func();', ...
                'end'};
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'AddSemicolonsToStatements', true, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'Comment-only line indentation failed.');
        end

        function testSwitchBlockIndentation(testCase)
            rawCode = { ...
                'switch variable_expr', ...
                'case 1 % Comment for case 1', ...
                'disp("Option 1");', ...
                '    % Indented comment', ...
                'case {2,3}', ...
                '  subroutine_call(variable_expr);', ...
                'otherwise', ...
                '  disp("Other");', ...
                'end % Switch end' ...
            };
            expectedCode = { ...
                'switch variable_expr', ...
                '    case 1 % Comment for case 1', ...
                '        disp("Option 1");', ...
                '            % Indented comment', ... % Comments maintain their relative indent from current block level + case level
                '    case {2,3}', ...
                '        subroutine_call(variable_expr);', ...
                '    otherwise', ...
                '        disp("Other");', ...
                'end % Switch end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'Switch block indentation failed.');
        end
        
        function testNestedSwitchBlockIndentation(testCase)
            rawCode = { ...
                'switch val1', ...
                'case 1', ...
                '  switch val2', ...
                '  case 10', ...
                '    disp(110);', ...
                '  otherwise', ...
                '    disp(100);', ...
                '  end', ... % Inner switch end
                'case 2', ...
                '  disp(2);', ...
                'end % Outer switch end'};
            expectedCode = { ...
                'switch val1', ...
                '    case 1', ...
                '        switch val2', ...
                '            case 10', ...
                '                disp(110);', ...
                '            otherwise', ...
                '                disp(100);', ...
                '        end', ... % Inner switch end
                '    case 2', ...
                '        disp(2);', ...
                'end % Outer switch end'};
            actualCode = code_beautifier(rawCode, 'IndentSize', 4, 'SpaceAroundOperators', false, 'RemoveRedundantSemicolons', false, 'AddSemicolonsToStatements', true);
            testCase.verifyEqual(actualCode, expectedCode, 'Nested Switch block indentation failed.');
        end


        function testBlankLineHandlingMinAndPreserve(testCase)
            rawCode = { ...
                'line1;', ...
                '', ... % User has one blank line
                'if condition1', ... % Block 1
                '    line2;', ...
                'end', ...
                'if condition2', ... % Block 2, no user blank lines before
                '    line3;', ...
                'end', ...
                '', ... % User has three blank lines
                '', ...
                '', ...
                'if condition3', ... % Block 3
                '    line4;', ...
                'end' ...
            };
            expectedCode = { ...
                'line1;', ...
                '', % Min=1, Existing=1 (preserved) -> 1 blank
                '', % Min=1 -> 1 blank
                'if condition1', ...
                '    line2;', ...
                'end', ...
                '', % Min=1, Existing=0 -> 1 blank
                'if condition2', ...
                '    line3;', ...
                'end', ...
                '', % Min=1, Existing=1 (preserved from user's multiple) -> 1 blank
                'if condition3', ...
                '    line4;', ...
                'end' ...
            };
            % PreserveBlankLines=true (default) collapses multiple to one.
            % MinBlankLinesBeforeBlock=1 ensures at least one blank.
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', true, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'MinBlankLinesBeforeBlock=1 and PreserveBlankLines=true interaction failed.');

            expectedCodeMin2 = { ...
                'line1;', ...
                '', % Min=2, Existing=1 (preserved) -> adds 1 to make 2 blanks
                '', 
                'if condition1', ...
                '    line2;', ...
                'end', ...
                '', % Min=2, Existing=0 -> adds 2 blanks
                '',
                'if condition2', ...
                '    line3;', ...
                'end', ...
                '', % Min=2, Existing=1 (preserved) -> adds 1 to make 2 blanks
                '',
                'if condition3', ...
                '    line4;', ...
                'end' ...
            };
            actualCodeMin2 = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 2, 'PreserveBlankLines', true, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCodeMin2, expectedCodeMin2, 'MinBlankLinesBeforeBlock=2 and PreserveBlankLines=true interaction failed.');
        end
        
        function testPreserveBlankLinesFalseWithMinBlank(testCase)
             rawCode = { ...
                'line1;', ...
                '', ... 
                '', ... % User has two blank lines
                'if condition1', ... 
                '    line2;', ...
                'end'};
            expectedCode = { ...
                'line1;', ...
                '', % Min=1, Preserve=false means user blanks are ignored, MinBlank forces one.
                'if condition1', ...
                '    line2;', ...
                'end'};
            actualCode = code_beautifier(rawCode, 'MinBlankLinesBeforeBlock', 1, 'PreserveBlankLines', false, 'IndentSize',4,'SpaceAroundOperators',false, 'RemoveRedundantSemicolons', false);
            testCase.verifyEqual(actualCode, expectedCode, 'MinBlankLinesBeforeBlock=1 and PreserveBlankLines=false interaction failed.');
        end

        % --- Test Style Presets ---
        function testPresetDefault(testCase)
            rawCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x,z);if x > 0;;y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else;y=0;end;% comment', ...
                'for k=1:3;disp(k);end; % another comment', ...
                'end' ...
            };
            % Default: IndentSize: 4, UseTabs: false, SpaceAroundOperators: true, SpaceAfterComma: true,
            % ContinuationIndentOffset: 1, PreserveBlankLines: true, MinBlankLinesBeforeBlock: 0,
            % RemoveRedundantSemicolons: true, AddSemicolonsToStatements: false
            expectedCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y = myFunc(x, z)', ...
                '    if x > 0; y = x * z + 1; myMatrix = [1, 2, 3; 4, 5, 6]; else; y = 0; end; % comment', ...
                '    for k = 1:3; disp(k); end; % another comment', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'Default');
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset Default failed.');
        end

        function testPresetMathWorksStyle(testCase)
            rawCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x,z);if x > 0;;y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else;y=0;end;% comment', ...
                'for k=1:3;disp(k);end; % another comment', ...
                'end' ...
            };
            % MathWorksStyle: IndentSize: 4, MinBlankLinesBeforeBlock: 1, other defaults same as 'Default'
            expectedCode = { ...
                '% Test snippet for beautifier presets', ...
                '', ... % Added by MinBlankLinesBeforeBlock=1
                'function y = myFunc(x, z)', ...
                '    if x > 0; y = x * z + 1; myMatrix = [1, 2, 3; 4, 5, 6]; else; y = 0; end; % comment', ...
                '    for k = 1:3; disp(k); end; % another comment', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'MathWorksStyle');
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset MathWorksStyle failed.');
        end

        function testPresetCompactStyle(testCase)
            rawCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x,z);if x > 0;;y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else;y=0;end;% comment', ...
                'for k=1:3;disp(k);end; % another comment', ...
                'end' ...
            };
            % CompactStyle: IndentSize: 2, PreserveBlankLines: false, MinBlankLinesBeforeBlock: 0
            expectedCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y = myFunc(x, z)', ...
                '  if x > 0; y = x * z + 1; myMatrix = [1, 2, 3; 4, 5, 6]; else; y = 0; end; % comment', ...
                '  for k = 1:3; disp(k); end; % another comment', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'CompactStyle');
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset CompactStyle failed.');
        end

        function testPresetCompactWithIndentOverride(testCase)
            rawCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x,z);if x > 0;;y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else;y=0;end;% comment', ...
                'for k=1:3;disp(k);end; % another comment', ...
                'end' ...
            };
            % CompactStyle (IndentSize: 2, PreserveBlankLines: false) overridden by IndentSize: 4
            expectedCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y = myFunc(x, z)', ...
                '    if x > 0; y = x * z + 1; myMatrix = [1, 2, 3; 4, 5, 6]; else; y = 0; end; % comment', ...
                '    for k = 1:3; disp(k); end; % another comment', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'CompactStyle', 'IndentSize', 4);
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset CompactStyle with IndentSize override failed.');
        end

        function testPresetMathWorksWithMinBlankOverride(testCase)
            rawCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x,z);if x > 0;;y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else;y=0;end;% comment', ...
                'for k=1:3;disp(k);end; % another comment', ...
                'end' ...
            };
            % MathWorksStyle (MinBlankLinesBeforeBlock: 1) overridden by MinBlankLinesBeforeBlock: 0
            expectedCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y = myFunc(x, z)', ... % No blank line due to override
                '    if x > 0; y = x * z + 1; myMatrix = [1, 2, 3; 4, 5, 6]; else; y = 0; end; % comment', ...
                '    for k = 1:3; disp(k); end; % another comment', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'MathWorksStyle', 'MinBlankLinesBeforeBlock', 0);
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset MathWorksStyle with MinBlankLinesBeforeBlock override failed.');
        end

        function testPresetDefaultWithSpaceOperatorOverride(testCase)
            rawCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x,z);if x > 0;;y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else;y=0;end;% comment', ...
                'for k=1:3;disp(k);end; % another comment', ...
                'end' ...
            };
            % Default (SpaceAroundOperators: true) overridden by SpaceAroundOperators: false
            expectedCode = { ...
                '% Test snippet for beautifier presets', ...
                'function y=myFunc(x, z)', ... % Comma spacing still true
                '    if x>0; y=x*z+1; myMatrix = [1,2,3; 4,5,6]; else; y=0; end; % comment', ...
                '    for k=1:3; disp(k); end; % comment with space after ; if it was there from start
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'Default', 'SpaceAroundOperators', false);
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset Default with SpaceAroundOperators override failed.');
        end
        
        function testInvalidPresetName(testCase)
            rawCode = {'a=1;'};
            % This test assumes that code_beautifier.m should throw an error for an invalid preset name.
            % The current implementation of code_beautifier.m might not do this without explicit validation
            % (e.g., using validatestring or a custom check that errors).
            % If it doesn't error, this test will fail.
            % A typical error ID from inputParser if validatestring was used would be 'MATLAB:InputParser:ArgumentFailedValidation'
            % or 'MATLAB:mustBeMember'. If a custom error is thrown, the ID would be custom.
            % For now, we'll use a generic ID and expect it to be refined if the main code is updated.
            % Based on the current code_beautifier.m, no error is thrown.
            % However, the instructions *require* testing for an error.
            % I will use 'code_beautifier:InvalidStylePreset' as an example error ID
            % that *would* be appropriate if such validation was added.
            
            % If the main code IS NOT changed to throw an error, the correct test would be:
            % actualCode = code_beautifier(rawCode, 'StylePreset', 'NonExistentStyle');
            % expectedCode = code_beautifier(rawCode, 'StylePreset', 'Default'); % Or simply default formatted code
            % testCase.verifyEqual(actualCode, expectedCode, 'Invalid preset should apply default settings.');
            
            % Per instruction, testing for an error:
            rawCode = {'a=1;'}; % Define rawCode for the test
            testCase.verifyError(@() code_beautifier(rawCode, 'StylePreset', 'NonExistentStyle'), ...
                                 'code_beautifier:InvalidStylePreset', ...
                                 'Test for invalid preset name failed to throw expected error.');
        end

    end % methods (Test)

    methods (Access = private)
        function cleanupFile = createTempConfigFile(testCase, content)
            % Creates a temporary .mbeautifyrc file in the current directory (pwd)
            % and ensures it's deleted after the test.
            % testCase: The TestCase instance (used for addTeardown if needed, though onCleanup is often preferred).
            % content: String or cell array of strings to write to the file.
            
            configFilePath = fullfile(pwd, '.mbeautifyrc');
            
            % Ensure no pre-existing file interferes or causes permission issues if undeletable
            if exist(configFilePath, 'file')
                delete(configFilePath); 
            end

            fid = fopen(configFilePath, 'w');
            if fid == -1
                % In case of test environment issues, provide a clear error.
                error('test_code_beautifier:createTempConfigFile:FileOpenFailed', ...
                      'Failed to create temporary config file: %s. Check permissions in pwd.', configFilePath);
            end
            
            if iscell(content)
                for i = 1:length(content)
                    fprintf(fid, '%s\n', content{i});
                end
            else % char array
                fprintf(fid, '%s', content);
            end
            fclose(fid);
            
            % Ensure the file is deleted when the cleanupFile object is cleared
            % (typically at the end of the test method or on error).
            cleanupFile = onCleanup(@() deleteConfigFile(configFilePath));
        end
    end

    methods (Test)
        % --- Config File Tests ---

        function testNoConfigFilePresent(testCase)
            % Ensure beautifier works with default settings if no config file
            rawCode = {'if true;a=1;end'};
            expectedCode = { ...
                'if true', ...
                '    a = 1;', ... % Default IndentSize=4, SpaceAroundOperators=true
                'end' ...
            };
            
            % Ensure no config file from previous tests
            deleteConfigFile(fullfile(pwd, '.mbeautifyrc')); 
            
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'No config file should use default settings.');
        end

        function testBasicConfigFileApplication(testCase)
            rawCode = {'if true;a=1;end'};
            configFileContent = { ...
                'IndentSize = 2', ...
                'UseTabs = true', ...
                'SpaceAroundOperators = false' ...
            };
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                'if true', ...
                [sprintf('\t') 'a=1;'], ... % IndentSize=1 (for tabs), UseTabs=true, SpaceAroundOperators=false
                'end' ...
            };
            % IndentSize for UseTabs=true is 1 tab character.
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Basic config file options not applied.');
        end

        function testConfigFileOverrideByDirectArgument(testCase)
            rawCode = {'if true;a=1;end'};
            configFileContent = {'IndentSize = 2', 'SpaceAroundOperators = true'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                'if true', ...
                '        a=1;', ... % IndentSize=8 (direct), SpaceAroundOperators=false (direct)
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 8, 'SpaceAroundOperators', false);
            testCase.verifyEqual(actualCode, expectedCode, 'Config file options not overridden by direct arguments.');
        end

        function testConfigFileOverrideByPreset(testCase)
            rawCode = {'function foo;if true;a=1;end;end'}; % Added function for MinBlankLinesBeforeBlock
            configFileContent = {'IndentSize = 2', 'MinBlankLinesBeforeBlock = 0'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            % MathWorksStyle: IndentSize=4, MinBlankLinesBeforeBlock=1
            expectedCode = { ...
                '', ... % From MathWorksStyle MinBlankLinesBeforeBlock=1
                'function foo', ...
                '    if true', ...
                '        a = 1;', ... % IndentSize=4 (Preset)
                '    end', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'MathWorksStyle');
            testCase.verifyEqual(actualCode, expectedCode, 'Config file options not overridden by preset.');
        end

        function testPresetOverriddenByDirectArgumentWithConfig(testCase)
            rawCode = {'function foo;if true;a=1;end;end'};
            configFileContent = {'IndentSize = 2', 'MinBlankLinesBeforeBlock = 0', 'SpaceAroundOperators = false'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            % Config: IndentSize=2, MinBlank=0, SpaceOps=false
            % Preset (MathWorks): IndentSize=4, MinBlank=1, SpaceOps=true (default for preset)
            % Direct: IndentSize=8, MinBlank=2
            
            expectedCode = { ...
                '', ... % MinBlank=2 (Direct)
                '', ... % MinBlank=2 (Direct)
                'function foo', ...
                '        if true', ...
                '                a = 1;', ... % IndentSize=8 (Direct), SpaceOps=true (from Preset, as not directly overridden)
                '        end', ...
                'end' ...
            };
            % SpaceAroundOperators comes from the preset, as it's not a direct arg.
            actualCode = code_beautifier(rawCode, 'StylePreset', 'MathWorksStyle', 'IndentSize', 8, 'MinBlankLinesBeforeBlock', 2);
            testCase.verifyEqual(actualCode, expectedCode, 'Preset not overridden by direct argument when config is present.');
        end
        
        function testStylePresetInConfigFile(testCase)
            rawCode = {'function foo;if true;a=1;end;end'};
            configFileContent = {'StylePreset = CompactStyle'}; % Compact: IndentSize=2, PreserveBlankLines=false
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                'function foo', ... % No MinBlankLinesBeforeBlock from CompactStyle
                '  if true', ...   % IndentSize=2
                '    a = 1;', ...
                '  end', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset from config file not applied.');
        end

        function testStylePresetInConfigOverriddenByDirectPreset(testCase)
            rawCode = {'function foo;if true;a=1;end;end'};
            configFileContent = {'StylePreset = CompactStyle'}; % Compact: IndentSize=2, MinBlank=0
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            % MathWorksStyle: IndentSize=4, MinBlank=1
            expectedCode = { ...
                '', % MinBlank=1 from MathWorksStyle
                'function foo', ...
                '    if true', ...   % IndentSize=4
                '        a = 1;', ...
                '    end', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'StylePreset', 'MathWorksStyle');
            testCase.verifyEqual(actualCode, expectedCode, 'StylePreset from config not overridden by direct StylePreset.');
        end
        
        function testStylePresetInConfigWithDirectOptionOverride(testCase)
            rawCode = {'function foo;if true;a=1;end;end'};
            configFileContent = {'StylePreset = CompactStyle'}; % Compact: IndentSize=2
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                'function foo', ...
                '        if true', ...   % IndentSize=8 (Direct override)
                '                a = 1;', ...
                '        end', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'IndentSize', 8); % Direct option overrides preset from config
            testCase.verifyEqual(actualCode, expectedCode, 'Direct option did not override config-defined StylePreset option.');
        end


        function testInvalidLineInConfigFile(testCase)
            rawCode = {'a=1;'};
            configFileContent = { ...
                'IndentSize = 2', ...
                'ThisIsJustAWord', ... % Invalid line
                'UseTabs = true' ...
            };
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                [sprintf('\t') 'a=1;'] ... % IndentSize=1 (for tabs), UseTabs=true. Default SpaceAroundOperators=true.
            };
            
            % Check for warning related to invalid line
            testCase.verifyWarning(@() code_beautifier(rawCode), 'code_beautifier:InvalidLineInConfigFile');
            
            % Verify that valid options were still applied
            actualCode = code_beautifier(rawCode); % Run again to get output after warning check
            testCase.verifyEqual(actualCode, expectedCode, 'Valid options not applied with invalid line in config.');
        end

        function testUnsupportedOptionInConfigFile(testCase)
            rawCode = {'a=1;'};
            configFileContent = { ...
                'IndentSize = 3', ...
                'NonExistentOption = 123', ...
                'UseTabs = false' ...
            };
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                '   a = 1;' % IndentSize=3, UseTabs=false (so 3 spaces)
            };
            
            testCase.verifyWarning(@() code_beautifier(rawCode), 'code_beautifier:UnknownConfigFileOption');
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Valid options not applied with unsupported option in config.');
        end
        
        function testTypeMismatchInConfigFile(testCase)
            rawCode = {'a=1;'};
            configFileContent = { ...
                'IndentSize = four', ... % Invalid numeric
                'UseTabs = NotABoolean', ... % Invalid logical
                'SpaceAroundOperators = true' % Valid
            };
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                '    a = 1;' % Default IndentSize=4, Default UseTabs=false, SpaceAroundOperators=true
            };
            
            % Expect multiple warnings for invalid values
            testCase.verifyWarning(@() code_beautifier(rawCode), 'code_beautifier:InvalidValueInConfigFile');
            % It might throw multiple, so we check again, specifically for another.
            % This depends on MATLAB's warning behavior (if they get consolidated or repeated).
            % A more robust way would be to capture all warnings and check their identifiers.
            % For now, assume at least one is 'InvalidValueInConfigFile'.
            
            actualCode = code_beautifier(rawCode); % Run again to get the actual output
            testCase.verifyEqual(actualCode, expectedCode, 'Default options not used after type mismatches in config.');
        end
        
        function testCommentAndBlankLinesInConfigFile(testCase)
            rawCode = {'a=1;'};
            configFileContent = { ...
                '# This is a comment', ...
                'IndentSize = 2', ...
                '', ... % Blank line
                'UseTabs = true', ...
                '  # Indented comment', ...
                'SpaceAroundOperators = false # Trailing comment, value should be false'
            };
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                [sprintf('\t') 'a=1;'] ... % IndentSize=1 (tabs), UseTabs=true, SpaceAroundOperators=false
            };
            
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Config file with comments and blank lines not parsed correctly.');
        end
        
        function testConfigCaseInsensitiveKeys(testCase)
            rawCode = {'a=1;'};
            configFileContent = {'indentSIZE = 2', 'usetabs = TRUE'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
             expectedCode = { ...
                [sprintf('\t') 'a = 1;'] ... % IndentSize=1 (tabs), UseTabs=true. Default SpaceAroundOperators=true
            };
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Case-insensitive keys in config not handled.');
        end

        function testConfigStylePresetInvalidInFile(testCase)
            rawCode = {'a=1;'};
            configFileContent = {'StylePreset = NonExistentPreset'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>

            expectedCode = { ... % Should use default settings
                '    a = 1;'
            };
            % Expect warning for invalid preset in config
            testCase.verifyWarning(@() code_beautifier(rawCode), 'code_beautifier:InvalidStylePresetInConfigFile');
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'Defaults not used when config StylePreset is invalid.');
        end
        
        function testConfigOutputFormat(testCase)
            rawCode = {'a=1;', 'b=2;'};
            configFileContent = {'OutputFormat = char'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = sprintf('    a = 1;\n    b = 2;'); % Default IndentSize=4
            
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode, 'OutputFormat from config file not applied.');
            testCase.verifyClass(actualCode, 'char', 'OutputFormat from config did not return char.');
        end

    end % Config File Tests

    methods (Test)
        % --- AlignAssignments Tests ---
        function testAlignAssignmentsSimpleBlock(testCase)
            rawCode = { ...
                'a=1;', ...
                'longVarName=2;', ...
                'b = 3; % Comment' ...
            };
            expectedCode = { ...
                'a           = 1;', ...
                'longVarName = 2;', ...
                'b           = 3; % Comment' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'SpaceAroundOperators', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsSeparatedByEmptyLine(testCase)
            rawCode = { ...
                'x=10;', ...
                'yz=20;', ...
                '', ...
                'abc=30;', ...
                'd=40;' ...
            };
            expectedCode = { ...
                'x  = 10;', ...
                'yz = 20;', ...
                '', ...
                'abc = 30;', ...
                'd   = 40;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsSeparatedByCommentLine(testCase)
            rawCode = { ...
                'x=10;', ...
                'yz=20;', ...
                '% This is a comment', ...
                'abc=30;', ...
                'd=40;' ...
            };
            expectedCode = { ...
                'x  = 10;', ...
                'yz = 20;', ...
                '% This is a comment', ...
                'abc = 30;', ...
                'd   = 40;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end
        
        function testAlignAssignmentsSeparatedByKeyword(testCase)
            rawCode = { ...
                'x=10;', ...
                'yz=20;', ...
                'if true', ...
                '    abc=30;', ...
                '    d=40;', ...
                'end', ...
                'finalVar = 500;'...
            };
            expectedCode = { ...
                'x  = 10;', ...
                'yz = 20;', ...
                'if true', ...
                '    abc = 30;', ... % Aligned within their own block
                '    d   = 40;', ...
                'end', ...
                'finalVar = 500;' ... % Separate block of 1
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsWithIndentation(testCase)
            rawCode = { ...
                'if true', ...
                '    val1 = 100;', ...
                '    longerVal = 200; % Comment', ...
                '    % Inner comment', ...
                '    short = 1;',...
                'end' ...
            };
            expectedCode = { ...
                'if true', ...
                '    val1      = 100;', ...
                '    longerVal = 200; % Comment', ...
                '    % Inner comment', ...
                '    short     = 1;', ...
                'end' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsFalseIsDefault(testCase)
            rawCode = { ...
                'a=1;', ...
                'longVarName=2;', ...
                'b = 3; % Comment' ...
            };
            % Expected is essentially the default formatting without specific alignment
            expectedCode = { ...
                'a = 1;', ...
                'longVarName = 2;', ...
                'b = 3; % Comment' ...
            };
            actualCodeDefault = code_beautifier(rawCode); % AlignAssignments is false by default
            actualCodeFalse = code_beautifier(rawCode, 'AlignAssignments', false);
            testCase.verifyEqual(actualCodeDefault, expectedCode, 'Default behavior for AlignAssignments failed.');
            testCase.verifyEqual(actualCodeFalse, expectedCode, 'AlignAssignments=false failed.');
        end

        function testAlignAssignmentsNoEqualsSign(testCase)
            rawCode = { ...
                'a = 10;', ...
                'disp("hello");', ... % No assignment
                'b = 20;' ...
            };
            expectedCode = { ...
                'a = 10;', ...
                'disp("hello");', ...
                'b = 20;' ... % Block of 1, no change other than standard spacing
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsWithComparisonOpsAndStrings(testCase)
            rawCode = { ...
                'text = "var=val"; % Assignment', ...
                'check = (x==1);   % Not an assignment for alignment', ...
                'anotherText = "equals = sign";', ...
                'result=compute(); % Assignment' ...
            };
            expectedCode = { ...
                'text        = "var=val"; % Assignment', ...
                'check = (x==1);   % Not an assignment for alignment', ...
                'anotherText = "equals = sign";', ... % This will align with text and result
                'result      = compute(); % Assignment' ...
            };
            % The line 'anotherText = ...' forms a block with 'text = ...' and 'result = ...'
            % because 'check = (x==1)' is not considered an alignable assignment by the current logic.
            % Let's refine the expected output based on how the implemented logic would group this.
            % If (x==1) breaks the block, then 'text' is a block of 1, 'anotherText' and 'result' form a new block.
            % The current logic for `isAssignable` checks for a valid single `=` not part of `==`, etc.
            % So, `check = (x==1)` will not be `isAssignable`.
            
            % Expected:
            % text = "var=val"; % block 1
            % check = (x==1);
            % anotherText = "equals = sign"; % block 2 (with result)
            % result      = compute();
            
            % Let's trace the logic more carefully:
            % 1. 'text = "var=val";' -> assignable, block1_lhs = [text], maxLhs=4
            % 2. 'check = (x==1);' -> not assignable (due to ==). Process block1.
            %    lines{1} = 'text = "var=val";' (no change as it's a block of 1)
            % 3. 'anotherText = "equals = sign";' -> assignable, block2_lhs = [anotherText], maxLhs=11
            % 4. 'result=compute();' -> assignable, same indent, block2_lhs = [anotherText, result], maxLhs=11
            % Process block2:
            %    lines{3} = 'anotherText = "equals = sign";'
            %    lines{4} = 'result      = compute();'
            
            expectedCodeRevised = { ...
                'text = "var=val"; % Assignment', ... % Block of 1, standard spacing
                'check = (x==1);   % Not an assignment for alignment', ...
                'anotherText = "equals = sign";', ...
                'result      = compute(); % Assignment' ...
            };

            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCodeRevised);
        end
        
        function testAlignAssignmentsVariedSpacing(testCase)
            rawCode = { ...
                'q   = 1;', ...
                'r=  2; %comment', ...
                'longerName   =333;', ...
                's      =  4;' ...
            };
            expectedCode = { ...
                'q          = 1;', ...
                'r          = 2; %comment', ...
                'longerName = 333;', ...
                's          = 4;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'SpaceAroundOperators', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end
        
        function testAlignAssignmentsNoSpaceAroundOp(testCase)
             rawCode = { ...
                'firstVar=100;', ...
                'secondVariable=2;' ...
            };
            expectedCode = { ...
                'firstVar      =100;', ... % Note: No space after = due to SpaceAroundOperators=false
                'secondVariable=2;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'SpaceAroundOperators', false);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsWithLineContinuations(testCase)
            rawCode = { ...
                'shortVar = 1;', ...
                'longVarName = ...', ...
                '    part2 + part3;', ...
                'anotherVar = 10;' ...
            };
            % Line continuation breaks the block.
            expectedCode = { ...
                'shortVar = 1;', ... % Block of 1
                'longVarName = ...', ... % Not an assignment line for alignment due to '...'
                '    part2 + part3;', ...
                'anotherVar = 10;' ... % Block of 1
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true);
            testCase.verifyEqual(actualCode, expectedCode);
        end
        
        function testAlignAssignmentsViaConfigFile(testCase)
            rawCode = {'a=1;','bb=22;'};
            configFileContent = {'AlignAssignments = true'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ...
                'a  = 1;', ...
                'bb = 22;' ...
            };
            actualCode = code_beautifier(rawCode);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsConfigOverriddenByDirectFalse(testCase)
            rawCode = {'a=1;','bb=22;'};
            configFileContent = {'AlignAssignments = true'};
            cleanup = testCase.createTempConfigFile(configFileContent); %#ok<NASGU>
            
            expectedCode = { ... % Default formatting, no alignment
                'a = 1;', ...
                'bb = 22;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', false);
            testCase.verifyEqual(actualCode, expectedCode);
        end
        
        function testAlignAssignmentsWithOnlyOneAssignableLineInBlock(testCase)
            rawCode = { ...
                'val = 10;', ...
                'if true',...
                '  anotherVal = 200;',...
                'end',...
                'final = 3000;'...
            };
            % Each of these is a block of 1, so no change other than standard spacing.
            expectedCode = { ...
                'val = 10;', ...
                'if true',...
                '    anotherVal = 200;',...
                'end',...
                'final = 3000;'...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',4);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsWithCommentInBlock(testCase)
            rawCode = { ...
              'alpha = 1; % Leading comment on line', ...
              'betaGamma = 22;', ...
              '% This is a full line comment in the block', ...
              'delta = 333; % Trailing comment', ...
              'epsilonZetaOmega = 4444;' ...
            };
            expectedCode = { ...
              'alpha            = 1; % Leading comment on line', ...
              'betaGamma        = 22;', ...
              '% This is a full line comment in the block', ...
              'delta            = 333; % Trailing comment', ...
              'epsilonZetaOmega = 4444;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',0); % IndentSize 0 for simplicity
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsWithMultipleCommentsInBlock(testCase)
            rawCode = { ...
                'first = 10;', ...
                '% Comment 1', ...
                '% Comment 2', ...
                'secondValue = 200;', ...
                'third = 3;', ...
                '% Comment 3 after an assignment', ...
                'fourthVeryLongName = 4000;' ...
            };
            expectedCode = { ...
                'first              = 10;', ...
                '% Comment 1', ...
                '% Comment 2', ...
                'secondValue        = 200;', ...
                'third              = 3;', ...
                '% Comment 3 after an assignment', ...
                'fourthVeryLongName = 4000;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',0);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsBlockBrokenByCommentThenDifferentIndent(testCase)
            rawCode = { ...
                'valA = 11;', ...
                'valBToo = 222;', ...
                '% This comment is part of the first block implicitly', ...
                '  nextVal = 3; % This line has different indent', ...
                '  anotherNext = 44;' ...
            };
            % The logic should be:
            % Block 1: valA, valBToo. Comment is associated with this block.
            % Then 'nextVal' has different indent, so block 1 is processed.
            % Block 2: nextVal, anotherNext
            expectedCode = { ...
                'valA    = 11;', ...
                'valBToo = 222;', ...
                '% This comment is part of the first block implicitly', ...
                '  nextVal     = 3; % This line has different indent', ...
                '  anotherNext = 44;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',0); % Base IndentSize 0
            testCase.verifyEqual(actualCode, expectedCode);
        end
        
        function testAlignAssignmentsBlockWithLeadingAndTrailingComments(testCase)
            rawCode = { ...
                '% Comment before block', ...
                'val1 = 1;', ...
                'longishVal2 = 22;', ...
                '% Comment within block', ...
                'val3 = 333;', ...
                '% Comment after block' ...
            };
            % Block 1: val1, longishVal2, val3. Comments before/after are separate.
            % Comment within is part of the block.
            expectedCode = { ...
                '% Comment before block', ...
                'val1        = 1;', ...
                'longishVal2 = 22;', ...
                '% Comment within block', ...
                'val3        = 333;', ...
                '% Comment after block' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',0);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsCommentItselfDoesNotStartBlock(testCase)
            rawCode = { ...
                '% Comment standalone', ...
                'data1 = 10;', ...
                'dataValue2 = 200;' ...
            };
            expectedCode = { ...
                '% Comment standalone', ...
                'data1      = 10;', ...
                'dataValue2 = 200;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',0);
            testCase.verifyEqual(actualCode, expectedCode);
        end

        function testAlignAssignmentsBlockNotBrokenByCommentWithDifferentIndentIfBlockIsEmpty(testCase)
            rawCode = { ...
                'firstLine = 1;', % Previous block ends
                '  % This comment has a different indent, but no active block to break from', ...
                '  valX = 123;', ...
                '  valYLonger = 456;' ...
            };
            expectedCode = { ...
                'firstLine = 1;', ...
                '  % This comment has a different indent, but no active block to break from', ...
                '  valX       = 123;', ...
                '  valYLonger = 456;' ...
            };
            actualCode = code_beautifier(rawCode, 'AlignAssignments', true, 'IndentSize',0);
            testCase.verifyEqual(actualCode, expectedCode);
        end


    end % AlignAssignments Tests
end % classdef

function deleteConfigFile(filePath)
    % Helper to delete config file, with a check for existence.
    if exist(filePath, 'file')
        delete(filePath);
    end
end
