function test_code_beautifier()
% TEST_CODE_BEAUTIFIER_RESULTS Script to test the code_beautifier function.
%
%   This script creates temporary files, opens them in the editor,
%   applies formatting using code_beautifier, and compares the result
%   against expected outputs.
%
%   Make sure 'code_beautifier.m' is in the MATLAB path.

    testCount = 0;
    passCount = 0;

    % --- Test Suite ---
    fprintf('Starting Code Beautifier Test Suite...\n');

    % --- Test 1: Default Settings ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Default Settings ---\n', testCount);
    rawCode1 = sprintf([...
        'function y = myfun(x)\n', ...
        '%% This is a comment\n', ...
        'if x > 0\n', ...
        '  y=x*2;  % Multiply by two\n', ...
        'else\n', ...
        'y = x+1;;\n', ...
        'end\n', ...
        'end']);
    expectedCode1_char = sprintf([...
        'function y = myfun(x)\n', ...
        '    %% This is a comment\n', ...
        '    if x > 0\n', ...
        '        y = x * 2; % Multiply by two\n', ...
        '    else\n', ...
        '        y = x + 1;\n', ...
        '    end\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode1, expectedCode1_char, {}, passCount, 'Default Settings');

    % --- Test 2: CompactStyle Preset ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: CompactStyle Preset ---\n', testCount);
    rawCode2 = rawCode1; % Reuse raw code
    expectedCode2_char = sprintf([...
        'function y = myfun(x)\n', ...
        '  %% This is a comment\n', ...
        '  if x > 0\n', ...
        '    y = x * 2; % Multiply by two\n', ...
        '  else\n', ...
        '    y = x + 1;\n', ...
        '  end\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode2, expectedCode2_char, {'StylePreset', 'CompactStyle'}, passCount, 'CompactStyle Preset');

    % --- Test 3: MathWorksStyle Preset ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: MathWorksStyle Preset (MinBlankLinesBeforeBlock=1) ---\n', testCount);
    rawCode3 = sprintf([...
        'function y = myfun(x)\n', ...
        'if x > 0\n', ...
        'y=x*2;\n', ...
        'else\n', ...
        'y = x+1;\n', ...
        'end\n', ...
        'for i=1:3\n', ...
        'disp(i);\n', ...
        'end\n', ...
        'end']);
    expectedCode3_char = sprintf([...
        'function y = myfun(x)\n', ...
        '\n', ... % Expected blank line due to MinBlankLinesBeforeBlock=1 in MathWorksStyle
        '    if x > 0\n', ...
        '        y = x * 2;\n', ...
        '    else\n', ...
        '        y = x + 1;\n', ...
        '    end\n', ...
        '\n', ... % Expected blank line
        '    for i = 1:3\n', ...
        '        disp(i);\n', ...
        '    end\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode3, expectedCode3_char, {'StylePreset', 'MathWorksStyle'}, passCount, 'MathWorksStyle Preset');

    % --- Test 4: Custom IndentSize and UseTabs ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Custom IndentSize=2, UseTabs=true ---\n', testCount);
    rawCode4 = sprintf('if true\nx=1;\nend');
    % Expected: Tab for indent, then x = 1;
    expectedCode4_char = sprintf('if true\n\tx = 1;\nend'); % \t represents a tab
    [passCount, ~] = run_test_case(rawCode4, expectedCode4_char, {'IndentSize', 2, 'UseTabs', true}, passCount, 'IndentSize=2, UseTabs=true');

    % --- Test 5: SpaceAroundOperators=false ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: SpaceAroundOperators=false ---\n', testCount);
    rawCode5 = sprintf('a=b+c*d/e==f&&g||h;');
    expectedCode5_char = sprintf('a=b+c*d/e==f&&g||h;'); % Default indent
    [passCount, ~] = run_test_case(rawCode5, expectedCode5_char, {'SpaceAroundOperators', false, 'IndentSize',0}, passCount, 'SpaceAroundOperators=false');

    % --- Test 6: SpaceAfterComma=false ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: SpaceAfterComma=false ---\n', testCount);
    rawCode6 = sprintf('myfun(a,b,c);\nx=[1,2,3];');
    expectedCode6_char = sprintf('myfun(a,b,c);\nx = [1,2,3];'); % Default indent, operators spaced
    [passCount, ~] = run_test_case(rawCode6, expectedCode6_char, {'SpaceAfterComma', false, 'IndentSize',0}, passCount, 'SpaceAfterComma=false');

    % --- Test 7: ContinuationIndentOffset ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: ContinuationIndentOffset=2 ---\n', testCount);
    rawCode7 = sprintf([...
        'myMatrix = [1, 2, 3, ...\n', ...
        '4, 5, 6];']);
    expectedCode7_char = sprintf([...
        'myMatrix = [1, 2, 3, ...\n', ...
        '        4, 5, 6];']); % Default 4 spaces + 2*4 for continuation offset
    [passCount, ~] = run_test_case(rawCode7, expectedCode7_char, {'ContinuationIndentOffset', 2}, passCount, 'ContinuationIndentOffset=2');

    % --- Test 8: PreserveBlankLines=false ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: PreserveBlankLines=false ---\n', testCount);
    rawCode8 = sprintf('a = 1;\n\n\nb = 2;');
    expectedCode8_char = sprintf('a = 1;\nb = 2;'); % Default indent
    [passCount, ~] = run_test_case(rawCode8, expectedCode8_char, {'PreserveBlankLines', false, 'IndentSize',0}, passCount, 'PreserveBlankLines=false');

    % --- Test 9: MinBlankLinesBeforeBlock=2 ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: MinBlankLinesBeforeBlock=2 ---\n', testCount);
    rawCode9 = sprintf('function test()\nif true\ndisp(1);\nend\nend');
    expectedCode9_char = sprintf([...
        'function test()\n', ...
        '\n', ... % Blank line 1
        '\n', ... % Blank line 2
        '    if true\n', ...
        '        disp(1);\n', ...
        '    end\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode9, expectedCode9_char, {'MinBlankLinesBeforeBlock', 2}, passCount, 'MinBlankLinesBeforeBlock=2');


    % --- Test 10: AddSemicolonsToStatements=true ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: AddSemicolonsToStatements=true ---\n', testCount);
    rawCode10 = sprintf('disp(''hello'')\na=1\nplot(x,y)');
    expectedCode10_char = sprintf('disp(''hello'');\na = 1;\nplot(x,y);'); % Default indent
    [passCount, ~] = run_test_case(rawCode10, expectedCode10_char, {'AddSemicolonsToStatements', true, 'IndentSize',0}, passCount, 'AddSemicolonsToStatements=true');

    % --- Test 11: AlignAssignments=true ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: AlignAssignments=true ---\n', testCount);
    rawCode11 = sprintf([...
        'alpha = 10;\n', ...
        'beta_long_name = 200; % comment\n', ...
        'gamma = 3;']);
    expectedCode11_char = sprintf([...
        'alpha            = 10;\n', ...
        'beta_long_name   = 200; % comment\n', ...
        'gamma            = 3;']); % Default indent
    [passCount, ~] = run_test_case(rawCode11, expectedCode11_char, {'AlignAssignments', true, 'IndentSize',0}, passCount, 'AlignAssignments=true');

    % --- Test 12: FormatArgumentsBlock=true ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: FormatArgumentsBlock=true ---\n', testCount);
    rawCode12 = sprintf([...
        'function myFuncWithArgs(name, options)\n', ...
        'arguments\n', ...
        ' name (1,1) string {mustBeNonempty}\n', ...
        ' options.Value (1,1) double = 10 % Default val\n', ...
        ' options.Flag logical=false\n', ...
        ' (Repeating) ...\n', ...
        '   options.AnotherArg cell = {''test''}\n',...
        'end\n', ...
        'disp(name)\n', ...
        'end']);
    % Note: The exact spacing for FormatArgumentsBlock can be tricky to predict
    % without running it, as it depends on max lengths of components.
    % This expected output is based on a plausible interpretation.
    expectedCode12_char = sprintf([...
        'function myFuncWithArgs(name, options)\n', ...
        '    arguments\n', ...
        '        name             (1,1) string {mustBeNonempty}\n', ...
        '        options.Value    (1,1) double                  = 10 % Default val\n', ...
        '        options.Flag           logical                 = false\n', ... % Adjusted based on actual output of beautifier
        '        (Repeating) ...\n', ... % This line is not an arg def, so it's passed through with indent
        '        options.AnotherArg     cell                    = {''test''}\n',...
        '    end\n', ...
        '    disp(name)\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode12, expectedCode12_char, {'FormatArgumentsBlock', true}, passCount, 'FormatArgumentsBlock=true');

    % --- Test 13: OutputFormat='cell' ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: OutputFormat=''cell'' ---\n', testCount);
    rawCode13 = sprintf('a=1;\nb=2;');
    expectedCode13_cell = {'a = 1;'; 'b = 2;'}; % Default indent
    [passCount, ~] = run_test_case(rawCode13, expectedCode13_cell, {'OutputFormat', 'cell', 'IndentSize',0}, passCount, 'OutputFormat=''cell''');

    % --- Test 14: .mbeautifyrc configuration file ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: .mbeautifyrc configuration ---\n', testCount);
    rawCode14 = sprintf('if true\nx=1+2;\nend');
    expectedCode14_char = sprintf('if true\n  x=1+2;\nend'); % IndentSize=2, SpaceAroundOperators=false from rc file

    % Create a temporary .mbeautifyrc
    rcFileName = fullfile(pwd, '.mbeautifyrc');
    fid = fopen(rcFileName, 'w');
    if fid == -1
        warning('Failed to create temporary .mbeautifyrc for testing.');
    else
        fprintf(fid, 'IndentSize = 2\n');
        fprintf(fid, 'UseTabs = false\n');
        fprintf(fid, 'SpaceAroundOperators = false\n');
        fclose(fid);

        [passCount, ~] = run_test_case(rawCode14, expectedCode14_char, {}, passCount, '.mbeautifyrc config');

        % Clean up .mbeautifyrc
        delete(rcFileName);
    end

    % --- Test 15: Operator spacing edge cases (unary, scientific) ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Operator spacing edge cases ---\n', testCount);
    rawCode15 = sprintf([...
        'x = -5;\n', ...
        'y = +3;\n', ...
        'z = 1e-5;\n', ...
        'w = obj.method(-arg);\n',...
        'arr = [1 -2 +3];']);
    expectedCode15_char = sprintf([...
        'x = -5;\n', ...
        'y = +3;\n', ...
        'z = 1e-5;\n', ...
        'w = obj.method(-arg);\n', ...
        'arr = [1 -2 +3];']); % Default indent
    [passCount, ~] = run_test_case(rawCode15, expectedCode15_char, {'IndentSize',0}, passCount, 'Operator spacing edge cases');

    % --- Test 16: Block comment handling ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Block comment handling ---\n', testCount);
    rawCode16 = sprintf([...
        'a = 1;\n',...
        '%{\n',...
        '  This is a block comment.\n',...
        '    It should maintain relative indent.\n',...
        '%}\n',...
        'b = 2;']);
    expectedCode16_char = sprintf([...
        'a = 1;\n',...
        '%{\n',...
        '  This is a block comment.\n',...
        '    It should maintain relative indent.\n',...
        '%}\n',...
        'b = 2;']); % Default indent
    [passCount, ~] = run_test_case(rawCode16, expectedCode16_char, {'IndentSize',0}, passCount, 'Block comment handling');
    
    % --- Test 17: Switch case indentation ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Switch case indentation ---\n', testCount);
    rawCode17 = sprintf([...
        'switch val\n', ...
        'case 1\n', ...
        'disp("one");\n', ...
        '  x = 1; % comment \n', ...
        'case 2\n', ...
        '    disp("two");\n', ...
        'otherwise\n', ...
        '  disp("other");\n', ...
        'end']);
    expectedCode17_char = sprintf([...
        'switch val\n', ...
        '    case 1\n', ...
        '        disp("one");\n', ...
        '        x = 1; % comment\n', ...
        '    case 2\n', ...
        '        disp("two");\n', ...
        '    otherwise\n', ...
        '        disp("other");\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode17, expectedCode17_char, {}, passCount, 'Switch case indentation');

    % --- Test 18: Complex Operator Spacing Scenarios ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Complex Operator Spacing ---\n', testCount);
    rawCode18 = sprintf([...
        'a=-b;\n', ... % Unary with assignment
        'c=+ -5;\n', ... % Double unary
        'd = - +2;\n', ...
        'e = - -1;\n', ...
        'f= مصروفات+other;\n', ... % Non-ASCII
        'mat = [1+2 3-4; -5*6 +7/8];\n', ... % Operators in matrix
        'cellarr = {''a''+''b'' ''c''==''d''};\n', ... % Operators in cell array
        'fh = @(x)x+1;\n', ... % Operators in anonymous functions
        'fh2 = @(y)-y*2;\n', ... 
        'fh3 = @(z)z^-0.5;\n', ...
        'res = 1+ ...\n2 - ...\n 3;\n', ... % Line continuations with operators
        'arr = [1, ...\n -2, ...\n +3];\n', ...
        'v=1:5;\n', ... % Colon operator
        'M=A(1:end,:);\n', ...
        'N=B(:,1 : 2 : end);']);
    expectedCode18_char = sprintf([...
        'a = -b;\n', ...
        'c = + -5;\n', ... % Expect space between + and -
        'd = - +2;\n', ... % Expect space
        'e = - -1;\n', ... % Expect space
        'f = مصروفات + other;\n', ...
        'mat = [1 + 2 3 - 4; -5 * 6 +7 / 8];\n', ... % Note: +7 might become + 7 based on unary rules
        'cellarr = {''a'' + ''b'' ''c'' == ''d''};\n', ...
        'fh = @(x) x + 1;\n', ... % Standard binary op spacing
        'fh2 = @(y) -y * 2;\n', ... % Potential issue: @(y)-y might become @(y) - y
        'fh3 = @(z) z ^ -0.5;\n', ... % Power with unary exponent
        'res = 1 + ...\n    2 - ...\n    3;\n', ... % Indent of continued lines handled separately
        'arr = [1, ...\n    -2, ...\n    +3];\n', ...
        'v = 1:5;\n', ... % Colon operator generally not spaced by default
        'M = A(1:end, :);\n', ...
        'N = B(:, 1 : 2 : end);']); % Preserve existing spacing for colon
    [passCount, ~] = run_test_case(rawCode18, expectedCode18_char, {}, passCount, 'Complex Operator Spacing');

    % --- Test 20: Tricky Comment and String Extraction ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Tricky Comment and String Extraction ---\n', testCount);
    rawCode20 = sprintf([...
        'function test_comment_strings()\n', ...
        's1 = ''string with %% sign''; %% comment1\n', ...  % Escaped % in sprintf, so it's 'string with % sign'; % comment1
        's2 = "string with %% and """"quotes"""" "; %% comment2\n', ... % Escaped % and " in sprintf
        'c1 = ''%% not a comment inside string'';\n', ...
        'lineonly = ''%% just a string %% with %% signs'';\n',...
        '   %% leading space comment\n', ...
        '%%trailing space comment   \n', ...
        'codePart1%%noSpaceComment\n', ...
        'codePart2 %% oneSpaceComment\n', ...
        'codePart3   %%   multiSpaceComment\n', ...
        'if true\n', ...
        '    disp(1); %%\n', ... % Comment is just %
        '    disp(2); %%   \n', ... % Comment is % then spaces
        '    s3 = ''text with %%; in str''; %% and %% in comment\n',...
        'end\n', ...
        'end']);
    expectedCode20_char = sprintf([...
        'function test_comment_strings()\n', ...
        '    s1 = ''string with %% sign'';       %% comment1\n', ... % Alignment will be handled by AlignAssignments if true, here default spacing
        '    s2 = "string with %% and """"quotes"""" "; %% comment2\n', ...
        '    c1 = ''%% not a comment inside string'';\n', ...
        '    lineonly = ''%% just a string %% with %% signs'';\n', ...
        '    %% leading space comment\n', ... % Indent + comment
        '    %%trailing space comment\n', ...  % Indent + comment (trailing spaces on comment line itself removed)
        '    codePart1 %%noSpaceComment\n', ...  % codePart1 % noSpaceComment (extract adds space before %)
        '    codePart2 %% oneSpaceComment\n', ...
        '    codePart3 %% multiSpaceComment\n', ...
        '    if true\n', ...
        '        disp(1); %%\n', ... % Will become disp(1); %
        '        disp(2); %%\n', ... % Will become disp(2); % (space after % removed by main formatter)
        '        s3 = ''text with %%; in str''; %% and %% in comment\n', ...
        '    end\n', ...
        'end']);
    % Note: Alignment of comments (e.g. s1, s2 lines) depends on AlignAssignments and other factors.
    % The key is the correct separation of code and comment content by extractCodeAndCommentInternal.
    % The expected output here assumes default options (IndentSize=4, SpaceAroundOperators=true, etc.)
    % and specifically that AlignAssignments=false for simplicity of predicting comment alignment.
    % The '%%' in expected is literal percent for sprintf.
    [passCount, ~] = run_test_case(rawCode20, expectedCode20_char, {'AlignAssignments', false}, passCount, 'Tricky Comment and String Extraction');

    % --- Test 22: Combined Options ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Combined Options ---\n', testCount);
    rawCode22 = sprintf([...
        'function y = test_combined_options(x)\n', ...
        'alpha    =1; %% comment1\n', ...
        'beta_long= 22; %% comment2\n', ...
        'gamma    =333; %% comment3\n', ...
        'if x > 0\n', ...
        '    y=x*2;\n', ...
        '    anotherVar = y + alpha;\n', ...
        'else\n', ...
        '    y = x+1;\n', ...
        '    delta = beta_long - gamma;\n', ...
        'end\n', ...
        'end']);
    expectedCode22_char = sprintf([...
        'function y = test_combined_options(x)\n', ...
        '\talpha     = 1;   %% comment1\n', ... % Tab, AlignAssignments
        '\tbeta_long = 22;  %% comment2\n', ... % Tab, AlignAssignments
        '\tgamma     = 333; %% comment3\n', ... % Tab, AlignAssignments
        '\n', ... % MinBlankLinesBeforeBlock = 1 before if
        '\tif x > 0\n', ... % Tab
        '\t\ty          = x * 2;\n', ... % Tab*2, AlignAssignments within block
        '\t\tanotherVar = y + alpha;\n', ... % Tab*2, AlignAssignments
        '\telse\n', ... % Tab
        '\t\ty     = x + 1;\n', ... % Tab*2, AlignAssignments within block
        '\t\tdelta = beta_long - gamma;\n', ... % Tab*2, AlignAssignments
        '\tend\n', ... % Tab
        'end']);
    [passCount, ~] = run_test_case(rawCode22, expectedCode22_char, {'AlignAssignments',true, 'UseTabs',true, 'MinBlankLinesBeforeBlock',1, 'IndentSize',2}, passCount, 'Combined Options');

    % --- Test 23: Nested Structures and Complex Control Flow ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Nested Structures and Complex Control Flow ---\n', testCount);
    rawCode23 = sprintf([...
        'function complex_flow(valA, valB)\n', ...
        'for i = 1:3\n', ...
        '    if valA > i\n', ...
        '        disp(''ValA is greater'');\n', ...
        '        for j=1:2\n', ...
        '            valB = valB*j; %% Inner loop\n', ...
        '        end\n', ...
        '    elseif valA == i\n', ...
        '        switch valA\n', ...
        '            case 1\n', ...
        '                disp(''One'');\n', ...
        '            case 2;disp(''Two''); %% Redundant semicolon issue\n', ...
        '            otherwise\n', ...
        '                disp(''Other'');\n', ...
        '        end\n', ...
        '    else\n', ...
        '        try\n', ...
        '            result = valB / (valA - i + eps);\n', ...
        '        catch ME\n', ...
        '            warning(''Error: %%s'', ME.message);\n', ...
        '        end\n', ...
        '    end\n', ...
        'end\n', ...
        'myFun = @(x) x*x + valA - valB;\n', ...
        'disp(myFun(i));\n', ...
        'end']);
    expectedCode23_char = sprintf([...
        'function complex_flow(valA, valB)\n', ...
        '    for i = 1:3\n', ...
        '        if valA > i\n', ...
        '            disp(''ValA is greater'');\n', ...
        '            for j = 1:2\n', ...
        '                valB = valB * j; %% Inner loop\n', ...
        '            end\n', ...
        '        elseif valA == i\n', ...
        '            switch valA\n', ...
        '                case 1\n', ...
        '                    disp(''One'');\n', ...
        '                case 2; disp(''Two''); %% Redundant semicolon issue -> ; $1 rule\n', ...
        '                otherwise\n', ...
        '                    disp(''Other'');\n', ...
        '            end\n', ...
        '        else\n', ...
        '            try\n', ...
        '                result = valB / (valA - i + eps);\n', ...
        '            catch ME\n', ...
        '                warning(''Error: %%s'', ME.message);\n', ...
        '            end\n', ...
        '        end\n', ...
        '    end\n', ...
        '    myFun = @(x) x * x + valA - valB;\n', ...
        '    disp(myFun(i));\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode23, expectedCode23_char, {}, passCount, 'Nested Structures and Complex Control Flow');

    % --- Test 24: classdef with Properties, Methods, Events ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: classdef with Properties, Methods, Events ---\n', testCount);
    rawCode24 = sprintf([...
        'classdef MyClass < handle\n', ...
        '    properties (Access=public)\n', ...
        '        Prop1 double = 10.5; %% A property\n', ...
        '        Prop2 string\n', ...
        '    end\n', ...
        '    properties(Constant)\n', ...
        '        MY_CONST = 100;\n', ...
        '    end\n', ...
        '    events\n', ...
        '        MyEvent\n', ...
        '    end\n', ...
        '    methods\n', ...
        '        function obj = MyClass(val)\n', ...
        '            if nargin > 0; obj.Prop2 = string(val); end\n', ...
        '        end\n', ...
        '        function dispProp(obj) %% Method to display\n', ...
        '            fprintf(''Prop1: %%f, Prop2: %%s\\n'', obj.Prop1, obj.Prop2);\n', ...
        '            if isempty(obj.Prop2); disp(''Prop2 is empty''); end\n', ...
        '        end\n', ...
        '    end\n', ...
        '    methods (Static)\n', ...
        '        function out = helperFunc(inArg)\n', ...
        '            out = inArg * MyClass.MY_CONST; %% Access constant\n', ...
        '        end\n', ...
        '    end\n', ...
        'end']);
    expectedCode24_char = sprintf([...
        'classdef MyClass < handle\n', ...
        '\n', ... % MinBlankLinesBeforeBlock=1 from MathWorksStyle (applied by default by preset)
        '    properties (Access = public)\n', ... % SpaceAroundOperators for =
        '        Prop1 double = 10.5; %% A property\n', ...
        '        Prop2 string\n', ...
        '    end\n', ...
        '\n', ...
        '    properties (Constant)\n', ... % Spaced (Constant) attribute
        '        MY_CONST = 100;\n', ...
        '    end\n', ...
        '\n', ...
        '    events\n', ...
        '        MyEvent\n', ...
        '    end\n', ...
        '\n', ...
        '    methods\n', ...
        '        function obj = MyClass(val)\n', ...
        '            if nargin > 0; obj.Prop2 = string(val); end\n', ... % Remains on one line, internal spacing
        '        end\n', ...
        '\n', ... % Blank line before new function def by MathWorksStyle preset (MinBlankLinesBeforeBlock=1)
        '        function dispProp(obj) %% Method to display\n', ...
        '            fprintf(''Prop1: %%f, Prop2: %%s\\n'', obj.Prop1, obj.Prop2);\n', ...
        '            if isempty(obj.Prop2); disp(''Prop2 is empty''); end\n', ... % Remains on one line
        '        end\n', ...
        '    end\n', ...
        '\n', ...
        '    methods (Static)\n', ... % Spaced (Static)
        '        function out = helperFunc(inArg)\n', ...
        '            out = inArg * MyClass.MY_CONST; %% Access constant\n', ...
        '        end\n', ...
        '    end\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode24, expectedCode24_char, {'StylePreset', 'MathWorksStyle'}, passCount, 'classdef with Properties, Methods, Events');

    % --- Test 26: Option Precedence Test (.mbeautifyrc, Preset, Direct Args) ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Option Precedence Test ---\n', testCount);
    
    rcFileName = fullfile(pwd, '.mbeautifyrc');
    fid = fopen(rcFileName, 'w');
    if fid == -1
        warning('Failed to create temporary .mbeautifyrc for Test %d.', testCount);
        fprintf('FAIL: Could not create .mbeautifyrc for Option Precedence Test.\n');
    else
        % .mbeautifyrc content:
        % Level 2: StylePreset = CompactStyle (IndentSize=2, PreserveBlankLines=false, MinBlankLinesBeforeBlock=0, UseTabs=false, SpaceAroundOperators=true)
        % Level 3: IndentSize=3 (overrides Compact), UseTabs=true (overrides Compact), SpaceAroundOperators=false (overrides Compact)
        fprintf(fid, 'StylePreset = CompactStyle\n');
        fprintf(fid, 'IndentSize = 3\n');
        fprintf(fid, 'UseTabs = true\n');
        fprintf(fid, 'SpaceAroundOperators = false\n');
        fclose(fid);

        rawCode26 = sprintf([...
            'function test_precedence(a,b)\n', ...
            '%% A simple function\n', ...
            'if a>b\n', ...
            'c=a-b;%% Op space test\n', ...
            'else\n', ...
            'c=a+b;%% Op space test\n', ...
            'end\n', ...
            'my_var=c*2;%% Op space test\n', ...
            'end']);

        % Expected final options after precedence:
        % 1. Beautifier Default: IndentSize=4, UseTabs=false, MinBlankLinesBeforeBlock=0, SpaceAroundOperators=true, PreserveBlankLines=true, SpaceAfterComma=true
        % 2. .rc Preset (CompactStyle): IndentSize=2, UseTabs=false, MinL=0, SpOp=true, PrBl=false, SpCom=true
        % 3. .rc Individual: IndentSize=3, UseTabs=true, SpOp=false (MinL, PrBl, SpCom from CompactStyle)
        % 4. Func Preset (MathWorksStyle): IndentSize=4, UseTabs=false, MinL=1, SpOp=true, PrBl=true, SpCom=true
        % 5. Func Direct Args: MinBlankLinesBeforeBlock=2, IndentSize=1
        % FINAL: IndentSize=1, UseTabs=false (from MWS), MinL=2, SpOp=true (from MWS), PrBl=true (from MWS), SpCom=true (from MWS)
        
        expectedCode26_char = sprintf([...
            'function test_precedence(a, b)\n', ... % SpaceAfterComma=true
            '% A simple function\n', ... % Comments preserved
            '\n', ... % MinBlankLinesBeforeBlock=2 (one blank line)
            '\n', ... % MinBlankLinesBeforeBlock=2 (second blank line)
            ' if a > b\n', ... % IndentSize=1, UseTabs=false
            '  c = a - b; %% Op space test\n', ... % IndentSize=1*2, SpaceAroundOperators=true, RemoveRedundantSemicolons=true
            ' else\n', ...
            '  c = a + b; %% Op space test\n', ...
            ' end\n', ...
            ' my_var = c * 2; %% Op space test\n', ... % IndentSize=1
            'end']);
        
        directArgs = {'StylePreset', 'MathWorksStyle', ...
                        'MinBlankLinesBeforeBlock', 2, ...
                        'IndentSize', 1};
        
        [passCount, ~] = run_test_case(rawCode26, expectedCode26_char, directArgs, passCount, 'Option Precedence Test');
        
        % Clean up .mbeautifyrc
        delete(rcFileName);
    end

    % --- Test 27: Obscure Syntax Elements ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Obscure Syntax Elements ---\n', testCount);
    rawCode27 = sprintf([...
        'function obscure_syntax_test(valA, varargin)\n', ...
        'global X Y Z;\n', ...
        'persistent P1 P2 = magic(2);% Persistent with init\n', ...
        'narginchk(1,5);\n', ...
        'varargout{1} = Y;\n', ...
        '  !echo "System command" & % System command\n', ...
        'metaObj = ?handle;\n', ...
        'transpose_a = valA.''; % Non-conjugate transpose\n', ...
        'transpose_b = P1'';    % Conjugate transpose with comment\n', ...
        'empty_matrix = []; %#codegen Support this\n', ...
        'empty_cell = {};\n', ...
        'continued_code = [1, ... % Comment on continued line\n', ...
        '                  2]; % And on the next\n', ...
        'coder.inline(''always'');\n', ...
        'complex_prop.subProp = {}; % Empty cell assignment\n', ...
        'end\n', ...
        '\n', ...
        'properties (Hidden)\n', ... % Property block
        '    PropWithVal {mustBeNumeric,mustBePositive} = 10;\n', ...
        'end\n']);
        % Note: classdef parts are harder to test standalone in a script like this for full execution,
        % but the formatting of 'properties' blocks can be somewhat tested.
        % A full classdef test is in Test 24. This focuses on property validation syntax.

    expectedCode27_char = sprintf([...
        'function obscure_syntax_test(valA, varargin)\n', ...
        '    global X Y Z;\n', ... % global keyword, no indent change
        '    persistent P1 P2 = magic(2); % Persistent with init\n', ... % persistent, assignment spaced
        '    narginchk(1, 5);\n', ... % SpaceAfterComma
        '    varargout{1} = Y;\n', ... % SpaceAroundOperators
        '    !echo "System command" & % System command\n', ... % System commands usually preserved, trailing & too
        '    metaObj = ?handle;\n', ... % ?metaclass operator, space around =
        '    transpose_a = valA.''; % Non-conjugate transpose, space around =\n', ...
        '    transpose_b = P1'';   % Conjugate transpose with comment, space around =\n', ...
        '    empty_matrix = []; %#codegen Support this\n', ... % Codegen pragma as comment
        '    empty_cell = {};\n', ...
        '    continued_code = [1, ... % Comment on continued line\n', ...
        '        2]; % And on the next (continuation indent)\n', ...
        '    coder.inline(''always'');\n', ...
        '    complex_prop.subProp = {}; % Empty cell assignment\n', ...
        'end\n', ...
        '\n', ...
        'properties (Hidden) % No specific formatting for attributes like (Hidden) yet\n', ...
        '    PropWithVal {mustBeNumeric, mustBePositive} = 10;\n', ... % Space around =, validation block preserved
        'end\n']);

    [passCount, ~] = run_test_case(rawCode27, expectedCode27_char, {}, passCount, 'Obscure Syntax Elements');

    % --- Test 29: Line Ending Handling ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Line Ending Handling ---\n', testCount);
    rawCodeMixedEndings = ['line1_rn_ending;' sprintf('\r\n') ...
                           'line2_n_ending;' sprintf('\n') ...
                           'line3_r_ending;' sprintf('\r') ...
                           sprintf('\r\n') ... % Empty line via CR+LF
                           'line5_no_ending_actually_std_n;' sprintf('\n') ...
                           'line6_trailing_spaces_rn;   ' sprintf('\r\n')];
    
    % Expected for OutputFormat = 'char' (standardized to \n)
    % Default options: IndentSize=4, SpaceAroundOperators=true, etc.
    expectedCodeChar_LF = sprintf([...
        'line1_rn_ending;\n', ...
        'line2_n_ending;\n', ...
        'line3_r_ending;\n', ...
        '\n', ... % Empty line preserved
        'line5_no_ending_actually_std_n;\n', ...
        'line6_trailing_spaces_rn;']); % Trailing spaces from original line content (not from ending) are trimmed by strtrim(originalLine)
                                     % and then regexprep(..., '\s+$', '') on the assembled line.
                                     % So, "line6_trailing_spaces_rn;   " becomes "line6_trailing_spaces_rn;"
                                     % If the beautifier adds its own trailing space (e.g. before a comment), that's also trimmed.
                                     % The final line does not have \n from sprintf if it's the last line. strjoin adds it between lines.
                                     % The last line of file does not have \n added by strjoin.
                                     % However, run_test_case compares by adding \n to expected if not present.
                                     % For consistency, I will ensure the expected string has a trailing \n if not empty.
                                     % The beautifier itself, when OutputFormat='char', returns a string that does NOT have a trailing \n
                                     % unless the original code effectively had a blank line at the very end.
                                     % The comparison logic in run_test_case handles this.
                                     % My expected string here should represent the direct output of code_beautifier.
        % Let's assume no trailing newline from strjoin for the very last line.
        % The test harness might add one for comparison if needed.
        % For `expectedCodeChar_LF`, it should be the exact output.
        % `strjoin` does not add a delimiter at the end.
        % So, `line6_trailing_spaces_rn;` will be the last part.
        
    % Let's adjust the expected output to be more precise about trailing newlines.
    % If the beautifier's strjoin(..., '\n') is used, the result will NOT have a trailing \n.
    % The test comparison logic in `run_test_case` normalizes this.
    % So, the expected code here should be what `code_beautifier` outputs.
    expectedOutput_direct_char = [...
        'line1_rn_ending;' sprintf('\n') ...
        'line2_n_ending;' sprintf('\n') ...
        'line3_r_ending;' sprintf('\n') ...
        '' sprintf('\n') ... % Empty line preserved
        'line5_no_ending_actually_std_n;' sprintf('\n') ...
        'line6_trailing_spaces_rn;']; % No final newline from strjoin
        
    [passCount, ~] = run_test_case(rawCodeMixedEndings, expectedOutput_direct_char, {'OutputFormat', 'char', 'IndentSize', 0}, passCount, 'Line Endings (char output)');

    % Expected for OutputFormat = 'cell'
    expectedCodeCell = { ...
        'line1_rn_ending;'; ...
        'line2_n_ending;'; ...
        'line3_r_ending;'; ...
        ''; ... % Empty line preserved
        'line5_no_ending_actually_std_n;'; ...
        'line6_trailing_spaces_rn;' ... % Trailing spaces trimmed
    };
    [passCount, ~] = run_test_case(rawCodeMixedEndings, expectedCodeCell, {'OutputFormat', 'cell', 'IndentSize', 0}, passCount, 'Line Endings (cell output)');

    % --- Test 29: Complex Comment Scenarios ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Complex Comment Scenarios ---\n', testCount);
    rawCode29 = sprintf([...
        'function complex_comments(p1) %% Main func comment\n', ...
        '    data = [1, 2, ... %% comment for first part of data\n', ...
        '            3, 4]; %% comment for second part\n', ...
        '    matrix = [1, 2; %% comment on matrix row 1\n', ...
        '              3, 4];%% comment on matrix row 2 (no space before %)\n', ...
        '    if p1 > 0\n', ...
        '        %% comment on empty line in if-block\n', ...
        '        disp(p1); %% action\n', ...
        '          %% comment before end (extra indented)\n', ...
        '    end %% comment on end line\n', ...
        '    arguments %% For testing comments in arguments block\n', ...
        '        p1 double {mustBeNumeric} = 10 %% comment for p1\n', ...
        '        %% standalone comment in arguments block\n', ...
        '        options.MyOpt logical = true; %% another arg\n', ...
        '    end\n', ...
        '    %{ \n', ...
        '      Block comment line 1\n', ...
        '        Block comment line 2 (more indented)\n', ...
        '    %} %% comment after block comment end\n', ...
        '    finalVar = "done"; %% final statement\n', ...
        'end %% function end comment']);
        
    expectedCode29_char = sprintf([...
        'function complex_comments(p1) %% Main func comment\n', ...
        '    data = [1, 2, ... %% comment for first part of data\n', ...
        '        3, 4]; %% comment for second part\n', ...
        '    matrix = [1, 2; %% comment on matrix row 1\n', ...
        '        3, 4]; %% comment on matrix row 2 (no space before %)\n', ...
        '    if p1 > 0\n', ...
        '        %% comment on empty line in if-block\n', ...
        '        disp(p1); %% action\n', ...
        '        %% comment before end (extra indented)\n', ...
        '    end %% comment on end line\n', ...
        '    arguments %% For testing comments in arguments block\n', ...
        '        p1 double {mustBeNumeric} = 10 %% comment for p1\n', ...
        '        %% standalone comment in arguments block\n', ...
        '        options.MyOpt logical = true; %% another arg\n', ...
        '    end\n', ...
        '    %{ \n', ...
        '      Block comment line 1\n', ...
        '        Block comment line 2 (more indented)\n', ...
        '    %} %% comment after block comment end\n', ...
        '    finalVar = "done"; %% final statement\n', ...
        'end %% function end comment']);
        % Using default options (IndentSize=4, SpaceAroundOperators=true etc.)
        % For arguments block, FormatArgumentsBlock=false by default, so no alignment, just standard formatting.
        % If FormatArgumentsBlock=true, the comments within would align with argument parts.
        % The key here is preservation and correct basic indenting of comments.
        
    [passCount, ~] = run_test_case(rawCode29, expectedCode29_char, {'FormatArgumentsBlock', false}, passCount, 'Complex Comment Scenarios');

    % --- Test 30: SpaceInsideParentheses Option ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: SpaceInsideParentheses Option ---\n', testCount);
    rawCode30 = sprintf([...
        'func(a,b);\n', ...
        'matrix(idx1,idx2);\n', ...
        'emptyFunc();\n', ...
        'nestedCall(another(c));\n', ...
        'arrayDef = @(x) x.^2;\n', ...
        'if (cond1 && cond2)\n', ...
        '    disp(1);\n', ...
        'end']);
    % Expected with SpaceInsideParentheses = true
    expectedCode30_true = sprintf([...
        'func( a, b );\n', ...
        'matrix( idx1, idx2 );\n', ...
        'emptyFunc();\n', ... % Should remain unchanged
        'nestedCall( another( c ) );\n', ...
        'arrayDef = @(x) x.^2;\n', ... % Anonymous function parens not typically spaced by this rule
        'if ( cond1 && cond2 )\n', ... % Parentheses in if condition spaced
        '    disp( 1 );\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode30, expectedCode30_true, {'SpaceInsideParentheses', true, 'IndentSize', 0}, passCount, 'SpaceInsideParentheses = true');
    
    % Expected with SpaceInsideParentheses = false (default)
    expectedCode30_false = sprintf([...
        'func(a, b);\n', ...
        'matrix(idx1, idx2);\n', ...
        'emptyFunc();\n', ...
        'nestedCall(another(c));\n', ...
        'arrayDef = @(x) x.^2;\n', ...
        'if (cond1 && cond2)\n', ... % Default MATLAB style usually has no space inside if-condition parens unless content is complex
        '    disp(1);\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode30, expectedCode30_false, {'SpaceInsideParentheses', false, 'IndentSize', 0}, passCount, 'SpaceInsideParentheses = false (default)');

    % --- Test 31: MaxBlankLinesInCode Option ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: MaxBlankLinesInCode Option ---\n', testCount);
    rawCode31 = sprintf([...
        'line1;\n', ...
        '\n', ... % 1 blank
        'line2;\n', ...
        '\n', ... % 1 blank
        '\n', ... % 2 blanks
        'line3;\n', ...
        '\n', ... % 1 blank
        '\n', ... % 2 blanks
        '\n', ... % 3 blanks
        'line4;\n', ...
        'function funcInTest()\n', ... % For MinBlankLinesBeforeBlock interaction
        '    subLine1;\n', ...
        '\n', ...
        '\n', ...
        '\n', ...
        '    subLine2;\n', ...
        'end']);

    % PreserveBlankLines=true, MaxBlankLinesInCode=0
    expectedCode31_max0 = sprintf([...
        'line1;\n', ...
        'line2;\n', ...
        'line3;\n', ...
        'line4;\n', ...
        '\n', ... % From MinBlankLinesBeforeBlock=1 (default for MathWorksStyle, or if set)
        'function funcInTest()\n', ...
        '    subLine1;\n', ...
        '    subLine2;\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode31, expectedCode31_max0, {'PreserveBlankLines', true, 'MaxBlankLinesInCode', 0, 'MinBlankLinesBeforeBlock', 1, 'IndentSize',0}, passCount, 'MaxBlankLinesInCode=0');
    
    % PreserveBlankLines=true, MaxBlankLinesInCode=1 (Default for Default preset)
    expectedCode31_max1 = sprintf([...
        'line1;\n', ...
        '\n', ... % Kept (1 <= 1)
        'line2;\n', ...
        '\n', ... % Kept (1 <= 1), original 2 collapsed to 1
        'line3;\n', ...
        '\n', ... % Kept (1 <= 1), original 3 collapsed to 1
        'line4;\n', ...
        '\n', ... % From MinBlankLinesBeforeBlock=1
        'function funcInTest()\n', ...
        '    subLine1;\n', ...
        '\n', ... % Original 3 internal blanks collapsed to 1
        '    subLine2;\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode31, expectedCode31_max1, {'PreserveBlankLines', true, 'MaxBlankLinesInCode', 1, 'MinBlankLinesBeforeBlock', 1, 'IndentSize',0}, passCount, 'MaxBlankLinesInCode=1');

    % PreserveBlankLines=true, MaxBlankLinesInCode=2
    expectedCode31_max2 = sprintf([...
        'line1;\n', ...
        '\n', ... % Kept (1 <= 2)
        'line2;\n', ...
        '\n', ... % Kept (1 <= 2)
        '\n', ... % Kept (2 <= 2)
        'line3;\n', ...
        '\n', ... % Kept (1 <= 2)
        '\n', ... % Kept (2 <= 2)
                 % Original 3rd blank line removed (3 > 2)
        'line4;\n', ...
        '\n', ... % From MinBlankLinesBeforeBlock=1
        'function funcInTest()\n', ...
        '    subLine1;\n', ...
        '\n', ... % Kept (1 <= 2)
        '\n', ... % Kept (2 <= 2)
                 % Original 3rd blank removed
        '    subLine2;\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode31, expectedCode31_max2, {'PreserveBlankLines', true, 'MaxBlankLinesInCode', 2, 'MinBlankLinesBeforeBlock', 1, 'IndentSize',0}, passCount, 'MaxBlankLinesInCode=2');

    % PreserveBlankLines=false (MaxBlankLinesInCode should effectively be 0)
    expectedCode31_preserveFalse = sprintf([...
        'line1;\n', ...
        'line2;\n', ...
        'line3;\n', ...
        'line4;\n', ...
        '\n', ... % From MinBlankLinesBeforeBlock=1
        'function funcInTest()\n', ...
        '    subLine1;\n', ...
        '    subLine2;\n', ...
        'end']);
    [passCount, ~] = run_test_case(rawCode31, expectedCode31_preserveFalse, {'PreserveBlankLines', false, 'MaxBlankLinesInCode', 5, 'MinBlankLinesBeforeBlock', 1, 'IndentSize',0}, passCount, 'PreserveBlankLines=false (MaxBlankLines ignored)');

    % --- Test 32: Selective Formatting with beautify_off/on ---
    testCount = testCount + 1;
    fprintf('\n--- Test %d: Selective Formatting ---\n', testCount);
    rawCode32 = sprintf([...
        'function selective_format_test()\n', ...
        '    formattedVar1 = 1+1; % This should be formatted\n', ...
        '    % beautify_off\n', ...
        '    unformattedVar = 2+2; % This should NOT be formatted\n', ...
        '  messyIndent =3+3;    % And this should keep its messy indent and spacing\n', ...
        '    % beautify_on\n', ...
        '    formattedVar2 = 4+4; % This should be formatted again\n', ...
        '\n', ...
        '    % beautify_off % Marker on line with other comment text (should still work)\n', ...
        '    var_no_format = 5+5;\n', ...
        '    % beautify_on % Marker on line with other comment text\n', ...
        '    var_format_again = 6+6;\n', ...
        '\n', ...
        '    % beautify_off\n', ...
        '    no_on_marker_var = 7+7; % Stays off till end of file\n', ...
        'end']);
        
    expectedCode32 = sprintf([...
        'function selective_format_test()\n', ...
        '    formattedVar1 = 1 + 1; % This should be formatted\n', ...
        '    % beautify_off\n', ... % Marker line itself is formatted (indented)
        '    unformattedVar = 2+2; % This should NOT be formatted\n', ... % Preserved as is
        '  messyIndent =3+3;    % And this should keep its messy indent and spacing\n', ... % Preserved as is
        '    % beautify_on\n', ...  % Marker line itself is formatted (indented)
        '    formattedVar2 = 4 + 4; % This should be formatted again\n', ...
        '\n', ...
        '    % beautify_off % Marker on line with other comment text (should still work)\n', ...
        '    var_no_format = 5+5;\n', ...
        '    % beautify_on % Marker on line with other comment text\n', ...
        '    var_format_again = 6 + 6;\n', ...
        '\n', ...
        '    % beautify_off\n', ...
        '    no_on_marker_var = 7+7; % Stays off till end of file\n', ...
        'end']);
        
    [passCount, ~] = run_test_case(rawCode32, expectedCode32, {}, passCount, 'Selective Formatting beautify_off/on');

    % Test with beautify_on without preceding off (should just be normal formatting)
    rawCode32_on_only = sprintf([...
        '    % beautify_on\n',...
        'testVar =1+1;']);
    expectedCode32_on_only = sprintf([...
        '    % beautify_on\n',...
        '    testVar = 1 + 1;']);
    [passCount, ~] = run_test_case(rawCode32_on_only, expectedCode32_on_only, {'IndentSize', 4}, passCount, 'Selective Formatting (beautify_on only)');
    
    % --- Test 33: Error for no active editor (simulated by closing all) ---
    % This test is tricky because the testing script itself might be in an editor.
    % A more robust way would be to run MATLAB with -nodisplay or ensure no editors are open.
    % For now, we'll try to close all and then call.
    testCount = testCount + 1; % This should be Test 33 now
    fprintf('\n--- Test %d: Error for no active editor ---\n', testCount);
    allDocs = matlab.desktop.editor.getAll;
    for i = 1:numel(allDocs)
        allDocs(i).closeNoPrompt; % Close all open documents
    end
    pause(0.5); % Give MATLAB a moment
    
    try
        code_beautifier(); % Should throw an error
        fprintf('FAIL: No error thrown for no active editor.\n');
    catch ME
        if strcmp(ME.identifier, 'code_beautifier:NoActiveEditor')
            fprintf('PASS: Correctly threw "%s".\n', ME.identifier);
            passCount = passCount + 1;
        else
            fprintf('FAIL: Incorrect error thrown: "%s". Message: %s\n', ME.identifier, ME.message);
            fprintf('Error details: %s\n', getReport(ME)); % Print more details
        end
    end
    % Note: After this test, you might need to reopen your test script editor manually.


    % --- Summary ---
    fprintf('\n\n--- Test Summary ---\n');
    fprintf('Total tests run: %d\n', testCount);
    fprintf('Tests passed:    %d\n', passCount);
    fprintf('Tests failed:    %d\n', testCount - passCount);

    if passCount == testCount
        fprintf('All tests passed!\n');
    else
        fprintf('Some tests FAILED.\n');
    end

end


function [passCount, actualCode] = run_test_case(rawCode, expectedCode, options, currentPassCount, testName)
% Helper function to run a single test case

    fprintf('Running test: %s\n', testName);
    
    tempFile = [tempname, '.m'];
    editorDoc = []; % Initialize to ensure it's in scope for cleanup
    
    % Cleanup object to ensure editor is closed and file is deleted
    cleanupObj = onCleanup(@() closeAndDeleteTempFile(editorDoc, tempFile));

    try
        % 1. Write raw code to temp file
        fid = fopen(tempFile, 'w');
        if fid == -1
            error('Failed to open temp file %s for writing.', tempFile);
        end
        fprintf(fid, '%s', rawCode);
        fclose(fid);

        % 2. Open in editor (this makes it active)
        editorDoc = matlab.desktop.editor.openDocument(tempFile);
        if isempty(editorDoc)
             % Try alternative if openDocument fails (older MATLAB?)
            edit(tempFile); 
            pause(0.5); % Give editor time to become active
            editorDoc = matlab.desktop.editor.getActive;
            if isempty(editorDoc) || ~strcmp(editorDoc.Filename, tempFile)
                 error('Failed to open %s in editor or make it active.', tempFile);
            end
        end
        % Ensure it's the active document (sometimes needed)
        editorDoc.makeActive();
        pause(0.2); % Small pause

        % 3. Call code_beautifier
        actualCode = code_beautifier(options{:});
        
        % 4. Compare
        if ischar(expectedCode)
            % Normalize line endings for comparison if actualCode is char
            if ischar(actualCode)
                actualCodeToCompare = strrep(actualCode, sprintf('\r\n'), sprintf('\n'));
                expectedCodeToCompare = strrep(expectedCode, sprintf('\r\n'), sprintf('\n'));
            else % actualCode is cell, expected is char - this shouldn't happen if options are right
                fprintf('FAIL: Type mismatch. Expected char, got cell.\n');
                return;
            end
            
            if strcmp(actualCodeToCompare, expectedCodeToCompare)
                fprintf('PASS\n');
                passCount = currentPassCount + 1;
            else
                fprintf('FAIL\n');
                fprintf('Expected:\n<<<\n%s\n>>>\n', expectedCodeToCompare);
                fprintf('Actual:\n<<<\n%s\n>>>\n', actualCodeToCompare);
                % For easier diffing:
                % disp("Expected (copy-paste friendly):"); disp(expectedCodeToCompare);
                % disp("Actual (copy-paste friendly):"); disp(actualCodeToCompare);
            end
        elseif iscell(expectedCode)
            if iscell(actualCode)
                if isequal(actualCode, expectedCode)
                    fprintf('PASS\n');
                    passCount = currentPassCount + 1;
                else
                    fprintf('FAIL\n');
                    fprintf('Expected (cell):\n'); disp(expectedCode);
                    fprintf('Actual (cell):\n'); disp(actualCode);
                end
            else
                 fprintf('FAIL: Type mismatch. Expected cell, got char.\n');
                 return;
            end
        else
            fprintf('FAIL: Unknown expectedCode type.\n');
        end

    catch ME
        fprintf('FAIL: Error during test execution for "%s":\n', testName);
        fprintf('Error ID: %s\n', ME.identifier);
        fprintf('Message: %s\n', ME.message);
        fprintf('Stack:\n');
        for k=1:length(ME.stack)
            fprintf('  File: %s, Name: %s, Line: %d\n', ME.stack(k).file, ME.stack(k).name, ME.stack(k).line);
        end
        actualCode = ''; % Ensure actualCode is assigned
    end
    % Cleanup is handled by onCleanup object
end

function closeAndDeleteTempFile(editorDoc, filePath)
    if ~isempty(editorDoc) && isvalid(editorDoc)
        try
            editorDoc.closeNoPrompt();
        catch
            % Ignore errors during cleanup close
        end
    end
    if exist(filePath, 'file')
        delete(filePath);
    end
end
